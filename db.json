{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"aae00029591415e9d39a52662f378ed30d9b8d93","modified":1489492212000},{"_id":"themes/landscape/_config.yml","hash":"bdeded63da3c73aca1766a5982fff92f0ffe0251","modified":1489492212000},{"_id":"source/favicon.ico","hash":"89969bc95c332e14d8a81b65582b00e388e884af","modified":1489492212000},{"_id":"themes/landscape/package.json","hash":"85358dc34311c6662e841584e206a4679183943f","modified":1489492212000},{"_id":"themes/landscape/README.md","hash":"c7e83cfe8f2c724fc9cac32bd71bb5faf9ceeddb","modified":1489492212000},{"_id":"themes/landscape/favicon.ico","hash":"89969bc95c332e14d8a81b65582b00e388e884af","modified":1489492212000},{"_id":"source/_posts/hello-world.md","hash":"539c92ab333f9d5b000c8d5482bc805bdb51bc45","modified":1498632708918},{"_id":"source/_posts/identity-number.md","hash":"5791f77ceb8d6bbe7bd38e629ad8e7b279d1a189","modified":1501490091857},{"_id":"source/_posts/cross-env.md","hash":"90df54d29457f3e5b7431bfd92639c310347d83c","modified":1498632947530},{"_id":"source/_posts/javascript-reg-1.md","hash":"3ab004fde245bc4023fe320f6bc949449892b94e","modified":1501490027264},{"_id":"source/_posts/javascript-reg-2.md","hash":"aadda312cbc81b75c05fa7fbcb80395c2415d6b4","modified":1501490032008},{"_id":"source/_posts/webpack-1-x.md","hash":"ee0778b33ac230133643bda6ba852fc7b1d4b39b","modified":1501490034560},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1489492212000},{"_id":"source/demo/demo.html","hash":"81d8e1e79d02039aec5c04f3b18f519a8c06e38e","modified":1489492212000},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1489492212000},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1489492212000},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1489492212000},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1489492212000},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1489492212000},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1489492212000},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1489492212000},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1489492212000},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1489492212000},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1489492212000},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"8fc23884cebf678d2dcfd17754025c164b9575ba","modified":1501483217708},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"01201725258ad2aaee606cd4dfdebc21b646def1","modified":1498628900190},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"a44f3cf5dc8910005cda9045bfaf2417e10b473b","modified":1498617713916},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"a8d1b2f41cfe7997e40c0fd2ab4d10dc9ce7cd93","modified":1501483256549},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"d7de6421497ffaf65e4f5fe4bed71fcea51fde80","modified":1489492212000},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1489492212000},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"abb134ea5b3915d4f5bca6db25c984349a7296a2","modified":1489492212000},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1489492212000},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"1ae755002b2aaab71c5885d64fe7885f0d66e21a","modified":1489492212000},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"c3fe5afa45d65efb655b5c5128100b3551fcb18f","modified":1489492212000},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1489492212000},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1489492212000},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"017bab14cbee808fe96c865ef688a21b33eb1261","modified":1489492212000},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"4ce79f0ed88fc095c51f48828fde6c1b574a5a30","modified":1489492212000},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1489492212000},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1489492212000},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1489492212000},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1489492212000},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1489492212000},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1489492212000},{"_id":"themes/landscape/source/css/_variables.styl","hash":"5e37a6571caf87149af83ac1cc0cdef99f117350","modified":1489492212000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1489492212000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1489492212000},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1489492212000},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1489492212000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1489492212000},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1489492212000},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1489492212000},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"f26d30355ba9144c51e700e8edc6a4ab6144ff9a","modified":1489492212000},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1489492212000},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1489492212000},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1489492212000},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1489492212000},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1489492212000},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1489492212000},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"d40be6bf2a550966eb4383180ce9d198474aa3c7","modified":1489492212000},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1489492212000},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"36eefe6332b86b66023a9884b754d305235846b4","modified":1489492212000},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"bc5487b9a0bfe5f745423331824d3f3637ccd430","modified":1489492212000},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1489492212000},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"587571665843a93aec2d1f9d7669bf742efba470","modified":1489492212000},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1489492212000},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1489492212000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1489492212000},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1489492212000},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1489492212000},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1489492212000},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1489492212000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1489492212000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1489492212000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1489492212000},{"_id":"themes/landscape/source/js/jquery.min.js","hash":"88158909c0c6075034f4fa7a0e1af68f2bddb2d1","modified":1489492212000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1489492212000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1489492212000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1489492212000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1489492212000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1489492212000},{"_id":"public/demo/demo.html","hash":"f1bb9329ad2f3452b60442f54fb4c199ed227ae0","modified":1501483274162},{"_id":"public/atom.xml","hash":"6f70abee79fbb9799645abc5112aaa507f03e2fd","modified":1501490104963},{"_id":"public/sitemap.xml","hash":"30ae7063da550c324fa9e480cd346812bc4a3d46","modified":1501490104967},{"_id":"public/identity-number/index.html","hash":"8a014e832de22407dd17670ff62bbc25e0e67316","modified":1501490105088},{"_id":"public/cross-env/index.html","hash":"4b78ed523a0c491072b57a47c00bb17373a47fe8","modified":1501490105097},{"_id":"public/hexo/index.html","hash":"e12e4819e1c0085f0f35227f344f12487a6a1059","modified":1501490105100},{"_id":"public/archives/index.html","hash":"adf0458cfff0c96cb8efd5c1ef1fd0c4552e67ff","modified":1501490105103},{"_id":"public/archives/2016/index.html","hash":"268fe18551eeba80e1a9e616e7abb4ca0341103e","modified":1501490105103},{"_id":"public/archives/2016/02/index.html","hash":"994c9eb4e97fe7dc3017ab4c7cc4a3df37a1073f","modified":1501490105104},{"_id":"public/archives/2017/index.html","hash":"2ccbaa0dad91d16fdc47a88bb8e69f27aabe602e","modified":1501490105105},{"_id":"public/archives/2017/06/index.html","hash":"550bb9db2af7ae8ba15b11892446d1d4031151e1","modified":1501490105105},{"_id":"public/archives/2017/07/index.html","hash":"2536371c7d7143034159b3625c56392e8a9face2","modified":1501490105106},{"_id":"public/categories/hexo/index.html","hash":"44a79acc4a8633a6386e15360460240333f93376","modified":1501490105106},{"_id":"public/categories/nodeJs/index.html","hash":"a0ef230df8e81259b55ede6ab7d96009a3587b7d","modified":1501490105106},{"_id":"public/categories/前端构建工具/index.html","hash":"0cee0eb3680d5123891f600294bf86d5b5442702","modified":1501490105106},{"_id":"public/index.html","hash":"7181d7f2b25598b9ad9ad50230d624c9e0f7c152","modified":1501490105107},{"_id":"public/tags/hexo/index.html","hash":"5e526ac419254d2b8c3710af33e488d37a58438d","modified":1501490105106},{"_id":"public/tags/技术细节-cross-dev/index.html","hash":"14084d63023328528795f805d5e74673d61c0c57","modified":1501490105106},{"_id":"public/tags/webpack-webpack1-x/index.html","hash":"f78208f577af6dc293da2fa0a7d4aede609dc681","modified":1501483274339},{"_id":"public/tags/JavaScript-验证身份证号码/index.html","hash":"742a646510d92ed409f40be220a28653121e251c","modified":1501483274339},{"_id":"public/javascript-reg-2/index.html","hash":"ecf55f4ff63ca464ed8e751265c9976aca3e2241","modified":1501490105107},{"_id":"public/javascript-reg-1/index.html","hash":"28981cdf6c9d63eb77e7a85c1e3b8d948370746d","modified":1501490105107},{"_id":"public/webpack-1-x/index.html","hash":"ec7dca25f75ca856cfaca87781a831dada5662c0","modified":1501490105107},{"_id":"public/categories/JavaScript/index.html","hash":"bf65a667e97ceb64b79a95b08ac266260f1df0c9","modified":1501490105111},{"_id":"public/tags/JavaScript/index.html","hash":"a8df6245eddc33b2c51b3eba93021d4186ff888b","modified":1501490105111},{"_id":"public/tags/JS实际应用/index.html","hash":"b1f1c219e9982b0cec92cf1f9816fdc1f27788a4","modified":1501490105111},{"_id":"public/tags/正则/index.html","hash":"6be3c662a6f58fa39858bcfdd3f5f5483c277642","modified":1501490105111},{"_id":"public/tags/webpack/index.html","hash":"9ddf6ee3c1c4160eab8189ff73530f612c3feff9","modified":1501490105112},{"_id":"public/tags/webpack1-x/index.html","hash":"b5e186fad4cca617fb9e9062ea183db370fb1978","modified":1501490105112}],"Category":[{"name":"hexo","_id":"cj5rrqje00004fkf167tj5wws"},{"name":"nodeJs","_id":"cj5rrqje90009fkf16wgnjn3f"},{"name":"前端构建工具","_id":"cj5rrqjed000efkf1ml67pyqw"},{"name":"JavaScript","_id":"cj5rwfv2x0001r4f1klorxwwd"}],"Data":[],"Page":[{"layout":"false","_content":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>xxx</title>\n</head>\n<body>\n\n</body>\n</html>","source":"demo/demo.html","raw":"layout: false\n--------\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>xxx</title>\n</head>\n<body>\n\n</body>\n</html>","date":"2017-03-15T04:53:31.098Z","updated":"2017-03-14T11:50:12.000Z","path":"demo/demo.html","title":"","comments":1,"_id":"cj5rrqjdr0001fkf1b2anze2q","content":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>xxx</title>\n</head>\n<body>\n\n</body>\n</html>","excerpt":"","more":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>xxx</title>\n</head>\n<body>\n\n</body>\n</html>"}],"Post":[{"title":"hexo博客相关命令","date":"2016-02-07T14:44:12.000Z","_content":"\nhexo相关笔记\n<!--more-->\n\n## Markdown语法\n\n1、 __分段__ 一个或多个回车\n2、 __换行__ 一个回车\n3、 __标题__ `#~######` 井号的个数表示几级标题\n4、 __引用__ `>`\n5、 __列表__ `*`，`+`，`-`，`1.`，选其中之一，注意后面有个空格\n6、 __链接__ `[文字](链接地址)`\n7、 __图片__ `![图片说明](图片地址)`，图片地址可以是本地路劲，也可以是网络地址\n8、 __强调__ `**文字**`，`__文字__`，`_文字_`，`*文字*`\n9、 __行内代码__ `` `代码` ``\n10、 __代码区块__ 四个空格开头 三个\\`\\`\\` 三个 \\~\\~\\~\n[更多markdown语法](http://markdown.tw/)\n[hexo扩充标签](https://hexo.io/zh-cn/docs/tag-plugins.html)\n\n## hexo常用命令\n\n+ **新建**\n\n    hexo new \"my blog\"\n新建的文件在hexo/source/_posts/my-blog.md\n\n+ **编译**\n\n    hexo generate\n部署前需要编译一下，编译后，会出现一个public文件夹，将所有的md文件编译成html文件\n\n+ **开启本地服务**\n\n    hexo server\n开启本地hexo服务\n\n+ **部署**\n\n    hexo deploy\n部署到github和gitcoffe上\n\n+ **清除public**\n\n    hexo clean\n清除source内多余的文件。\n\n+ **一般部署命令**\n{% codeblock lang:bash %}\nhexo clean\nhexo g\nhexo d\n// 合并 hexo d -g\n{% endcodeblock %}\n\n[官方文档](https://hexo.io/zh-cn/docs/commands.html)\n\n##  其他笔记\n_ 同时部署到 github 和 coding上 `_config.yml` 配置\n~~~\ndeploy:\n  type: git\n  repo:\n    github: git@github.com:guwei4321/guwei4321.github.io.git,master\n    coding: https://git.coding.net/guwei1989/guwei1989.git,coding-pages\n~~~\n\n## 其他同学的笔记\n<http://sfau.lt/b5lc0k>","source":"_posts/hello-world.md","raw":"title: hexo博客相关命令\ndate: 2016-02-07 22:44:12\npermalink: hexo\ntags:\n- hexo\ncategories:\n- hexo\n---\n\nhexo相关笔记\n<!--more-->\n\n## Markdown语法\n\n1、 __分段__ 一个或多个回车\n2、 __换行__ 一个回车\n3、 __标题__ `#~######` 井号的个数表示几级标题\n4、 __引用__ `>`\n5、 __列表__ `*`，`+`，`-`，`1.`，选其中之一，注意后面有个空格\n6、 __链接__ `[文字](链接地址)`\n7、 __图片__ `![图片说明](图片地址)`，图片地址可以是本地路劲，也可以是网络地址\n8、 __强调__ `**文字**`，`__文字__`，`_文字_`，`*文字*`\n9、 __行内代码__ `` `代码` ``\n10、 __代码区块__ 四个空格开头 三个\\`\\`\\` 三个 \\~\\~\\~\n[更多markdown语法](http://markdown.tw/)\n[hexo扩充标签](https://hexo.io/zh-cn/docs/tag-plugins.html)\n\n## hexo常用命令\n\n+ **新建**\n\n    hexo new \"my blog\"\n新建的文件在hexo/source/_posts/my-blog.md\n\n+ **编译**\n\n    hexo generate\n部署前需要编译一下，编译后，会出现一个public文件夹，将所有的md文件编译成html文件\n\n+ **开启本地服务**\n\n    hexo server\n开启本地hexo服务\n\n+ **部署**\n\n    hexo deploy\n部署到github和gitcoffe上\n\n+ **清除public**\n\n    hexo clean\n清除source内多余的文件。\n\n+ **一般部署命令**\n{% codeblock lang:bash %}\nhexo clean\nhexo g\nhexo d\n// 合并 hexo d -g\n{% endcodeblock %}\n\n[官方文档](https://hexo.io/zh-cn/docs/commands.html)\n\n##  其他笔记\n_ 同时部署到 github 和 coding上 `_config.yml` 配置\n~~~\ndeploy:\n  type: git\n  repo:\n    github: git@github.com:guwei4321/guwei4321.github.io.git,master\n    coding: https://git.coding.net/guwei1989/guwei1989.git,coding-pages\n~~~\n\n## 其他同学的笔记\n<http://sfau.lt/b5lc0k>","slug":"hexo","published":1,"updated":"2017-06-28T06:51:48.918Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5rrqjdm0000fkf1r2qsano6","content":"<p>hexo相关笔记<br><a id=\"more\"></a></p>\n<h2 id=\"Markdown语法\"><a href=\"#Markdown语法\" class=\"headerlink\" title=\"Markdown语法\"></a>Markdown语法</h2><p>1、 <strong>分段</strong> 一个或多个回车<br>2、 <strong>换行</strong> 一个回车<br>3、 <strong>标题</strong> <code>#~######</code> 井号的个数表示几级标题<br>4、 <strong>引用</strong> <code>&gt;</code><br>5、 <strong>列表</strong> <code>*</code>，<code>+</code>，<code>-</code>，<code>1.</code>，选其中之一，注意后面有个空格<br>6、 <strong>链接</strong> <code>[文字](链接地址)</code><br>7、 <strong>图片</strong> <code>![图片说明](图片地址)</code>，图片地址可以是本地路劲，也可以是网络地址<br>8、 <strong>强调</strong> <code>**文字**</code>，<code>__文字__</code>，<code>_文字_</code>，<code>*文字*</code><br>9、 <strong>行内代码</strong> <code>`代码` </code><br>10、 <strong>代码区块</strong> 四个空格开头 三个``` 三个 ~~~<br><a href=\"http://markdown.tw/\" target=\"_blank\" rel=\"external\">更多markdown语法</a><br><a href=\"https://hexo.io/zh-cn/docs/tag-plugins.html\" target=\"_blank\" rel=\"external\">hexo扩充标签</a></p>\n<h2 id=\"hexo常用命令\"><a href=\"#hexo常用命令\" class=\"headerlink\" title=\"hexo常用命令\"></a>hexo常用命令</h2><ul>\n<li><p><strong>新建</strong></p>\n<p>  hexo new “my blog”<br>新建的文件在hexo/source/_posts/my-blog.md</p>\n</li>\n<li><p><strong>编译</strong></p>\n<p>  hexo generate<br>部署前需要编译一下，编译后，会出现一个public文件夹，将所有的md文件编译成html文件</p>\n</li>\n<li><p><strong>开启本地服务</strong></p>\n<p>  hexo server<br>开启本地hexo服务</p>\n</li>\n<li><p><strong>部署</strong></p>\n<p>  hexo deploy<br>部署到github和gitcoffe上</p>\n</li>\n<li><p><strong>清除public</strong></p>\n<p>  hexo clean<br>清除source内多余的文件。</p>\n</li>\n<li><p><strong>一般部署命令</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br><span class=\"line\">hexo g</span><br><span class=\"line\">hexo d</span><br><span class=\"line\">// 合并 hexo d -g</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><a href=\"https://hexo.io/zh-cn/docs/commands.html\" target=\"_blank\" rel=\"external\">官方文档</a></p>\n<h2 id=\"其他笔记\"><a href=\"#其他笔记\" class=\"headerlink\" title=\"其他笔记\"></a>其他笔记</h2><p>_ 同时部署到 github 和 coding上 <code>_config.yml</code> 配置<br><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">deploy</span>:</span><br><span class=\"line\">  <span class=\"attribute\">type</span>: git</span><br><span class=\"line\">  <span class=\"attribute\">repo</span>:</span><br><span class=\"line\">    <span class=\"attribute\">github</span>: git<span class=\"variable\">@github</span>.<span class=\"attribute\">com</span>:guwei4321/guwei4321.github.io.git,master</span><br><span class=\"line\">    <span class=\"attribute\">coding</span>: <span class=\"attribute\">https</span>:<span class=\"comment\">//git.coding.net/guwei1989/guwei1989.git,coding-pages</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"其他同学的笔记\"><a href=\"#其他同学的笔记\" class=\"headerlink\" title=\"其他同学的笔记\"></a>其他同学的笔记</h2><p><a href=\"http://sfau.lt/b5lc0k\" target=\"_blank\" rel=\"external\">http://sfau.lt/b5lc0k</a></p>\n","excerpt":"<p>hexo相关笔记<br>","more":"</p>\n<h2 id=\"Markdown语法\"><a href=\"#Markdown语法\" class=\"headerlink\" title=\"Markdown语法\"></a>Markdown语法</h2><p>1、 <strong>分段</strong> 一个或多个回车<br>2、 <strong>换行</strong> 一个回车<br>3、 <strong>标题</strong> <code>#~######</code> 井号的个数表示几级标题<br>4、 <strong>引用</strong> <code>&gt;</code><br>5、 <strong>列表</strong> <code>*</code>，<code>+</code>，<code>-</code>，<code>1.</code>，选其中之一，注意后面有个空格<br>6、 <strong>链接</strong> <code>[文字](链接地址)</code><br>7、 <strong>图片</strong> <code>![图片说明](图片地址)</code>，图片地址可以是本地路劲，也可以是网络地址<br>8、 <strong>强调</strong> <code>**文字**</code>，<code>__文字__</code>，<code>_文字_</code>，<code>*文字*</code><br>9、 <strong>行内代码</strong> <code>`代码` </code><br>10、 <strong>代码区块</strong> 四个空格开头 三个``` 三个 ~~~<br><a href=\"http://markdown.tw/\">更多markdown语法</a><br><a href=\"https://hexo.io/zh-cn/docs/tag-plugins.html\">hexo扩充标签</a></p>\n<h2 id=\"hexo常用命令\"><a href=\"#hexo常用命令\" class=\"headerlink\" title=\"hexo常用命令\"></a>hexo常用命令</h2><ul>\n<li><p><strong>新建</strong></p>\n<p>  hexo new “my blog”<br>新建的文件在hexo/source/_posts/my-blog.md</p>\n</li>\n<li><p><strong>编译</strong></p>\n<p>  hexo generate<br>部署前需要编译一下，编译后，会出现一个public文件夹，将所有的md文件编译成html文件</p>\n</li>\n<li><p><strong>开启本地服务</strong></p>\n<p>  hexo server<br>开启本地hexo服务</p>\n</li>\n<li><p><strong>部署</strong></p>\n<p>  hexo deploy<br>部署到github和gitcoffe上</p>\n</li>\n<li><p><strong>清除public</strong></p>\n<p>  hexo clean<br>清除source内多余的文件。</p>\n</li>\n<li><p><strong>一般部署命令</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br><span class=\"line\">hexo g</span><br><span class=\"line\">hexo d</span><br><span class=\"line\">// 合并 hexo d -g</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><a href=\"https://hexo.io/zh-cn/docs/commands.html\">官方文档</a></p>\n<h2 id=\"其他笔记\"><a href=\"#其他笔记\" class=\"headerlink\" title=\"其他笔记\"></a>其他笔记</h2><p>_ 同时部署到 github 和 coding上 <code>_config.yml</code> 配置<br><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">deploy</span>:</span><br><span class=\"line\">  <span class=\"attribute\">type</span>: git</span><br><span class=\"line\">  <span class=\"attribute\">repo</span>:</span><br><span class=\"line\">    <span class=\"attribute\">github</span>: git<span class=\"variable\">@github</span>.<span class=\"attribute\">com</span>:guwei4321/guwei4321.github.io.git,master</span><br><span class=\"line\">    <span class=\"attribute\">coding</span>: <span class=\"attribute\">https</span>:<span class=\"comment\">//git.coding.net/guwei1989/guwei1989.git,coding-pages</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"其他同学的笔记\"><a href=\"#其他同学的笔记\" class=\"headerlink\" title=\"其他同学的笔记\"></a>其他同学的笔记</h2><p><a href=\"http://sfau.lt/b5lc0k\">http://sfau.lt/b5lc0k</a></p>"},{"title":"验证身份证号是否正确","date":"2017-07-31T06:22:34.000Z","_content":"\n\n\n在[正则基础深入应用](../javascript-reg-2#匹配身份证号码)中，我们使用了正则去验证身份证号，虽然根据规律写的那个正则能满足多数情况，但是还是会有一些漏网之鱼。后来发现有一个计算方法可以去判定这个身份证号是否正确。\n<!--more-->\n验证方法：\n1. 将身份证的前17位分别乘以不同的系数。从第一位到第十七位的系数分别为： 7－9－10－5－8－4－2－1－6－3－7－9－10－5－8－4－2。\n2. 将这18位数字和系数相乘的结果相加。\n3. 用加出来的和除以11，得出余数。\n4. 除以11，余数只能是0-10这11个数的一个。\n5. 以上得出的余数，对应着 [1,0,X,9,8,7,6,5,4,3,2]。\n\n根据以上结论，使用JS写相应程序，得出如下代码：\n\n/**\n * [checkID 验证身份证号码是否正确]\n * @param  {[String]} strIDCardnumber [必须是字符串，不然会触发大整数精度问题]\n * @return {[Boolean]}                [返回布尔值]\n */\nfunction checkID(strIDCardnumber){\n    var _isIDRule = false,\n        _sum = 0,\n        _strIDCardnumber = strIDCardnumber.toString(),\n        _coefficient = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2],\n        _mantissa = ['1', '0', 'X', '9', '8', '7', '6', '5', '4', '3', '2'];\n\n    for (var i = 0; i < 17; i++) {\n        _sum += Number(_strIDCardnumber.substring(i, i + 1)) * _coefficient[i];\n    }\n\n    if (_strIDCardnumber.substring(17) == _mantissa[_sum % 11]) {\n        _isIDRule = true;\n    }\n\n    return _isIDRule;\n}\n````\n\n以上就是验证身份证的程序代码，只要`checkID('430404196710021020')`调用就ok了。\n调用时必须要注意传入的值必须是字符类型，不然大于`2^53`时，就会触发大数字的精度问题。\n","source":"_posts/identity-number.md","raw":"title: 验证身份证号是否正确\ndate: 2017-07-31 14:22:34\ntags: \n- JavaScript\n- JS实际应用\ncategories:\n- JavaScript\n---\n\n\n\n在[正则基础深入应用](../javascript-reg-2#匹配身份证号码)中，我们使用了正则去验证身份证号，虽然根据规律写的那个正则能满足多数情况，但是还是会有一些漏网之鱼。后来发现有一个计算方法可以去判定这个身份证号是否正确。\n<!--more-->\n验证方法：\n1. 将身份证的前17位分别乘以不同的系数。从第一位到第十七位的系数分别为： 7－9－10－5－8－4－2－1－6－3－7－9－10－5－8－4－2。\n2. 将这18位数字和系数相乘的结果相加。\n3. 用加出来的和除以11，得出余数。\n4. 除以11，余数只能是0-10这11个数的一个。\n5. 以上得出的余数，对应着 [1,0,X,9,8,7,6,5,4,3,2]。\n\n根据以上结论，使用JS写相应程序，得出如下代码：\n\n/**\n * [checkID 验证身份证号码是否正确]\n * @param  {[String]} strIDCardnumber [必须是字符串，不然会触发大整数精度问题]\n * @return {[Boolean]}                [返回布尔值]\n */\nfunction checkID(strIDCardnumber){\n    var _isIDRule = false,\n        _sum = 0,\n        _strIDCardnumber = strIDCardnumber.toString(),\n        _coefficient = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2],\n        _mantissa = ['1', '0', 'X', '9', '8', '7', '6', '5', '4', '3', '2'];\n\n    for (var i = 0; i < 17; i++) {\n        _sum += Number(_strIDCardnumber.substring(i, i + 1)) * _coefficient[i];\n    }\n\n    if (_strIDCardnumber.substring(17) == _mantissa[_sum % 11]) {\n        _isIDRule = true;\n    }\n\n    return _isIDRule;\n}\n````\n\n以上就是验证身份证的程序代码，只要`checkID('430404196710021020')`调用就ok了。\n调用时必须要注意传入的值必须是字符类型，不然大于`2^53`时，就会触发大数字的精度问题。\n","slug":"identity-number","published":1,"updated":"2017-07-31T08:34:51.857Z","_id":"cj5rrqjdt0002fkf1cl0ob8z5","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在<a href=\"../javascript-reg-2#匹配身份证号码\">正则基础深入应用</a>中，我们使用了正则去验证身份证号，虽然根据规律写的那个正则能满足多数情况，但是还是会有一些漏网之鱼。后来发现有一个计算方法可以去判定这个身份证号是否正确。<br><a id=\"more\"></a><br>验证方法：</p>\n<ol>\n<li>将身份证的前17位分别乘以不同的系数。从第一位到第十七位的系数分别为： 7－9－10－5－8－4－2－1－6－3－7－9－10－5－8－4－2。</li>\n<li>将这18位数字和系数相乘的结果相加。</li>\n<li>用加出来的和除以11，得出余数。</li>\n<li>除以11，余数只能是0-10这11个数的一个。</li>\n<li>以上得出的余数，对应着 [1,0,X,9,8,7,6,5,4,3,2]。</li>\n</ol>\n<p>根据以上结论，使用JS写相应程序，得出如下代码：</p>\n<p>/**</p>\n<ul>\n<li>[checkID 验证身份证号码是否正确]</li>\n<li>@param  {[String]} strIDCardnumber [必须是字符串，不然会触发大整数精度问题]</li>\n<li><p>@return {[Boolean]}                [返回布尔值]<br>*/<br>function checkID(strIDCardnumber){<br> var _isIDRule = false,</p>\n<pre><code>_sum = 0,\n_strIDCardnumber = strIDCardnumber.toString(),\n_coefficient = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2],\n_mantissa = [&apos;1&apos;, &apos;0&apos;, &apos;X&apos;, &apos;9&apos;, &apos;8&apos;, &apos;7&apos;, &apos;6&apos;, &apos;5&apos;, &apos;4&apos;, &apos;3&apos;, &apos;2&apos;];\n</code></pre><p> for (var i = 0; i &lt; 17; i++) {</p>\n<pre><code>_sum += Number(_strIDCardnumber.substring(i, i + 1)) * _coefficient[i];\n</code></pre><p> }</p>\n<p> if (_strIDCardnumber.substring(17) == _mantissa[_sum % 11]) {</p>\n<pre><code>_isIDRule = true;\n</code></pre><p> }</p>\n<p> return _isIDRule;<br>}<br>````</p>\n</li>\n</ul>\n<p>以上就是验证身份证的程序代码，只要<code>checkID(&#39;430404196710021020&#39;)</code>调用就ok了。<br>调用时必须要注意传入的值必须是字符类型，不然大于<code>2^53</code>时，就会触发大数字的精度问题。</p>\n","excerpt":"<p>在<a href=\"../javascript-reg-2#匹配身份证号码\">正则基础深入应用</a>中，我们使用了正则去验证身份证号，虽然根据规律写的那个正则能满足多数情况，但是还是会有一些漏网之鱼。后来发现有一个计算方法可以去判定这个身份证号是否正确。<br>","more":"<br>验证方法：</p>\n<ol>\n<li>将身份证的前17位分别乘以不同的系数。从第一位到第十七位的系数分别为： 7－9－10－5－8－4－2－1－6－3－7－9－10－5－8－4－2。</li>\n<li>将这18位数字和系数相乘的结果相加。</li>\n<li>用加出来的和除以11，得出余数。</li>\n<li>除以11，余数只能是0-10这11个数的一个。</li>\n<li>以上得出的余数，对应着 [1,0,X,9,8,7,6,5,4,3,2]。</li>\n</ol>\n<p>根据以上结论，使用JS写相应程序，得出如下代码：</p>\n<p>/**</p>\n<ul>\n<li>[checkID 验证身份证号码是否正确]</li>\n<li>@param  {[String]} strIDCardnumber [必须是字符串，不然会触发大整数精度问题]</li>\n<li><p>@return {[Boolean]}                [返回布尔值]<br>*/<br>function checkID(strIDCardnumber){<br> var _isIDRule = false,</p>\n<pre><code>_sum = 0,\n_strIDCardnumber = strIDCardnumber.toString(),\n_coefficient = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2],\n_mantissa = [&apos;1&apos;, &apos;0&apos;, &apos;X&apos;, &apos;9&apos;, &apos;8&apos;, &apos;7&apos;, &apos;6&apos;, &apos;5&apos;, &apos;4&apos;, &apos;3&apos;, &apos;2&apos;];\n</code></pre><p> for (var i = 0; i &lt; 17; i++) {</p>\n<pre><code>_sum += Number(_strIDCardnumber.substring(i, i + 1)) * _coefficient[i];\n</code></pre><p> }</p>\n<p> if (_strIDCardnumber.substring(17) == _mantissa[_sum % 11]) {</p>\n<pre><code>_isIDRule = true;\n</code></pre><p> }</p>\n<p> return _isIDRule;<br>}<br>````</p>\n</li>\n</ul>\n<p>以上就是验证身份证的程序代码，只要<code>checkID(&#39;430404196710021020&#39;)</code>调用就ok了。<br>调用时必须要注意传入的值必须是字符类型，不然大于<code>2^53</code>时，就会触发大数字的精度问题。</p>"},{"title":"跨平台设置NODE_ENV","date":"2017-06-28T05:53:51.000Z","_content":"\n## 使用cross-env解决跨平台设置NODE_ENV\n今天把之前写的webpack打包程序从自己电脑（mac）拷贝到公司电脑（windows）使用，运行 `npm start`，报如下错误：\n<!--more-->\n````bash\nNODE_ENV=development webpack  --progress\n'NODE_ENV' 不是内部或外部命令，也不是可运行的程序\n或批处理文件。\n\nnpm ERR! Windows_NT 6.1.7601\nnpm ERR! argv \"C:\\\\Program Files\\\\nodejs\\\\node.exe\" \"d:\\\\Users\\\\wei.gu\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\npm\\\\bin\\\\n\npm-cli.js\" \"run\" \"dev\"\nnpm ERR! node v6.10.3\nnpm ERR! npm  v3.4.0\nnpm ERR! code ELIFECYCLE\nnpm ERR! webpack@1.0.0 dev: `NODE_ENV=development webpack  --progress`\nnpm ERR! Exit status 1\nnpm ERR!\nnpm ERR! Failed at the webpack@1.0.0 dev script 'NODE_ENV=development webpack  --progress'.\nnpm ERR! Make sure you have the latest version of node.js and npm installed.\nnpm ERR! If you do, this is most likely a problem with the webpack package,\nnpm ERR! not with npm itself.\nnpm ERR! Tell the author that this fails on your system:\nnpm ERR!     NODE_ENV=development webpack  --progress\nnpm ERR! You can get their info via:\nnpm ERR!     npm owner ls webpack\nnpm ERR! There is likely additional logging output above.\n\nnpm ERR! Please include the following file with any support request:\nnpm ERR!     D:\\learn\\webpack2\\npm-debug.log\n````\n意思是说，windows不支持通过 `NODE_ENV`的来设置环境变量（默认为`development`）。\nwebpack打包系统希望通过检查NODE_ENV来分别对开发环境和生成环境做不同处理，但是windows下报了如上的错误。\n\n### 解决方法\n后来网上查了查知道不同系统通过`NODE_ENV`设置环境变量命令是不同的。\n- linux && mac:\n````bash\nNODE_ENV=production\n````\n- windows:\n````bash\nset NODE_ENV=production\n````\n通过google找到了解决方案：{% link cross-env https://www.npmjs.com/package/cross-env  %}\n### 使用方法\n\n- 安装cross：`npm install cross-env --save-dev`\n- 在`NODE_ENV=xxx`前面加上`cross-env`\n\n这样就OK了。\n\n\n","source":"_posts/cross-env.md","raw":"title: 跨平台设置NODE_ENV\ndate: 2017-06-28 13:53:51\ntags:\n- 技术细节 cross-dev\ncategories:\n- nodeJs\n---\n\n## 使用cross-env解决跨平台设置NODE_ENV\n今天把之前写的webpack打包程序从自己电脑（mac）拷贝到公司电脑（windows）使用，运行 `npm start`，报如下错误：\n<!--more-->\n````bash\nNODE_ENV=development webpack  --progress\n'NODE_ENV' 不是内部或外部命令，也不是可运行的程序\n或批处理文件。\n\nnpm ERR! Windows_NT 6.1.7601\nnpm ERR! argv \"C:\\\\Program Files\\\\nodejs\\\\node.exe\" \"d:\\\\Users\\\\wei.gu\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\npm\\\\bin\\\\n\npm-cli.js\" \"run\" \"dev\"\nnpm ERR! node v6.10.3\nnpm ERR! npm  v3.4.0\nnpm ERR! code ELIFECYCLE\nnpm ERR! webpack@1.0.0 dev: `NODE_ENV=development webpack  --progress`\nnpm ERR! Exit status 1\nnpm ERR!\nnpm ERR! Failed at the webpack@1.0.0 dev script 'NODE_ENV=development webpack  --progress'.\nnpm ERR! Make sure you have the latest version of node.js and npm installed.\nnpm ERR! If you do, this is most likely a problem with the webpack package,\nnpm ERR! not with npm itself.\nnpm ERR! Tell the author that this fails on your system:\nnpm ERR!     NODE_ENV=development webpack  --progress\nnpm ERR! You can get their info via:\nnpm ERR!     npm owner ls webpack\nnpm ERR! There is likely additional logging output above.\n\nnpm ERR! Please include the following file with any support request:\nnpm ERR!     D:\\learn\\webpack2\\npm-debug.log\n````\n意思是说，windows不支持通过 `NODE_ENV`的来设置环境变量（默认为`development`）。\nwebpack打包系统希望通过检查NODE_ENV来分别对开发环境和生成环境做不同处理，但是windows下报了如上的错误。\n\n### 解决方法\n后来网上查了查知道不同系统通过`NODE_ENV`设置环境变量命令是不同的。\n- linux && mac:\n````bash\nNODE_ENV=production\n````\n- windows:\n````bash\nset NODE_ENV=production\n````\n通过google找到了解决方案：{% link cross-env https://www.npmjs.com/package/cross-env  %}\n### 使用方法\n\n- 安装cross：`npm install cross-env --save-dev`\n- 在`NODE_ENV=xxx`前面加上`cross-env`\n\n这样就OK了。\n\n\n","slug":"cross-env","published":1,"updated":"2017-06-28T06:55:47.530Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5rrqje10005fkf1lymjgte9","content":"<h2 id=\"使用cross-env解决跨平台设置NODE-ENV\"><a href=\"#使用cross-env解决跨平台设置NODE-ENV\" class=\"headerlink\" title=\"使用cross-env解决跨平台设置NODE_ENV\"></a>使用cross-env解决跨平台设置NODE_ENV</h2><p>今天把之前写的webpack打包程序从自己电脑（mac）拷贝到公司电脑（windows）使用，运行 <code>npm start</code>，报如下错误：<br><a id=\"more\"></a><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NODE_ENV=development webpack  --progress</span><br><span class=\"line\"><span class=\"string\">'NODE_ENV'</span> 不是内部或外部命令，也不是可运行的程序</span><br><span class=\"line\">或批处理文件。</span><br><span class=\"line\"></span><br><span class=\"line\">npm ERR! Windows_NT 6.1.7601</span><br><span class=\"line\">npm ERR! argv <span class=\"string\">\"C:\\\\Program Files\\\\nodejs\\\\node.exe\"</span> <span class=\"string\">\"d:\\\\Users\\\\wei.gu\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\npm\\\\bin\\\\n</span><br><span class=\"line\">pm-cli.js\"</span> <span class=\"string\">\"run\"</span> <span class=\"string\">\"dev\"</span></span><br><span class=\"line\">npm ERR! node v6.10.3</span><br><span class=\"line\">npm ERR! npm  v3.4.0</span><br><span class=\"line\">npm ERR! code ELIFECYCLE</span><br><span class=\"line\">npm ERR! webpack@1.0.0 dev: `NODE_ENV=development webpack  --progress`</span><br><span class=\"line\">npm ERR! Exit status 1</span><br><span class=\"line\">npm ERR!</span><br><span class=\"line\">npm ERR! Failed at the webpack@1.0.0 dev script <span class=\"string\">'NODE_ENV=development webpack  --progress'</span>.</span><br><span class=\"line\">npm ERR! Make sure you have the latest version of node.js and npm installed.</span><br><span class=\"line\">npm ERR! If you <span class=\"keyword\">do</span>, this is most likely a problem with the webpack package,</span><br><span class=\"line\">npm ERR! not with npm itself.</span><br><span class=\"line\">npm ERR! Tell the author that this fails on your system:</span><br><span class=\"line\">npm ERR!     NODE_ENV=development webpack  --progress</span><br><span class=\"line\">npm ERR! You can get their info via:</span><br><span class=\"line\">npm ERR!     npm owner ls webpack</span><br><span class=\"line\">npm ERR! There is likely additional logging output above.</span><br><span class=\"line\"></span><br><span class=\"line\">npm ERR! Please include the following file with any support request:</span><br><span class=\"line\">npm ERR!     D:\\learn\\webpack2\\npm-debug.log</span><br></pre></td></tr></table></figure></p>\n<p>意思是说，windows不支持通过 <code>NODE_ENV</code>的来设置环境变量（默认为<code>development</code>）。<br>webpack打包系统希望通过检查NODE_ENV来分别对开发环境和生成环境做不同处理，但是windows下报了如上的错误。</p>\n<h3 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h3><p>后来网上查了查知道不同系统通过<code>NODE_ENV</code>设置环境变量命令是不同的。</p>\n<ul>\n<li><p>linux &amp;&amp; mac:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NODE_ENV=production</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>windows:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">set</span> NODE_ENV=production</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>通过google找到了解决方案：<a href=\"https://www.npmjs.com/package/cross-env\" target=\"_blank\" rel=\"external\">cross-env</a></p>\n<h3 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h3><ul>\n<li>安装cross：<code>npm install cross-env --save-dev</code></li>\n<li>在<code>NODE_ENV=xxx</code>前面加上<code>cross-env</code></li>\n</ul>\n<p>这样就OK了。</p>\n","excerpt":"<h2 id=\"使用cross-env解决跨平台设置NODE-ENV\"><a href=\"#使用cross-env解决跨平台设置NODE-ENV\" class=\"headerlink\" title=\"使用cross-env解决跨平台设置NODE_ENV\"></a>使用cross-env解决跨平台设置NODE_ENV</h2><p>今天把之前写的webpack打包程序从自己电脑（mac）拷贝到公司电脑（windows）使用，运行 <code>npm start</code>，报如下错误：<br>","more":"<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NODE_ENV=development webpack  --progress</span><br><span class=\"line\"><span class=\"string\">'NODE_ENV'</span> 不是内部或外部命令，也不是可运行的程序</span><br><span class=\"line\">或批处理文件。</span><br><span class=\"line\"></span><br><span class=\"line\">npm ERR! Windows_NT 6.1.7601</span><br><span class=\"line\">npm ERR! argv <span class=\"string\">\"C:\\\\Program Files\\\\nodejs\\\\node.exe\"</span> <span class=\"string\">\"d:\\\\Users\\\\wei.gu\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\npm\\\\bin\\\\n</span><br><span class=\"line\">pm-cli.js\"</span> <span class=\"string\">\"run\"</span> <span class=\"string\">\"dev\"</span></span><br><span class=\"line\">npm ERR! node v6.10.3</span><br><span class=\"line\">npm ERR! npm  v3.4.0</span><br><span class=\"line\">npm ERR! code ELIFECYCLE</span><br><span class=\"line\">npm ERR! webpack@1.0.0 dev: `NODE_ENV=development webpack  --progress`</span><br><span class=\"line\">npm ERR! Exit status 1</span><br><span class=\"line\">npm ERR!</span><br><span class=\"line\">npm ERR! Failed at the webpack@1.0.0 dev script <span class=\"string\">'NODE_ENV=development webpack  --progress'</span>.</span><br><span class=\"line\">npm ERR! Make sure you have the latest version of node.js and npm installed.</span><br><span class=\"line\">npm ERR! If you <span class=\"keyword\">do</span>, this is most likely a problem with the webpack package,</span><br><span class=\"line\">npm ERR! not with npm itself.</span><br><span class=\"line\">npm ERR! Tell the author that this fails on your system:</span><br><span class=\"line\">npm ERR!     NODE_ENV=development webpack  --progress</span><br><span class=\"line\">npm ERR! You can get their info via:</span><br><span class=\"line\">npm ERR!     npm owner ls webpack</span><br><span class=\"line\">npm ERR! There is likely additional logging output above.</span><br><span class=\"line\"></span><br><span class=\"line\">npm ERR! Please include the following file with any support request:</span><br><span class=\"line\">npm ERR!     D:\\learn\\webpack2\\npm-debug.log</span><br></pre></td></tr></table></figure></p>\n<p>意思是说，windows不支持通过 <code>NODE_ENV</code>的来设置环境变量（默认为<code>development</code>）。<br>webpack打包系统希望通过检查NODE_ENV来分别对开发环境和生成环境做不同处理，但是windows下报了如上的错误。</p>\n<h3 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h3><p>后来网上查了查知道不同系统通过<code>NODE_ENV</code>设置环境变量命令是不同的。</p>\n<ul>\n<li><p>linux &amp;&amp; mac:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NODE_ENV=production</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>windows:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">set</span> NODE_ENV=production</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>通过google找到了解决方案：<a href=\"https://www.npmjs.com/package/cross-env\">cross-env</a></p>\n<h3 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h3><ul>\n<li>安装cross：<code>npm install cross-env --save-dev</code></li>\n<li>在<code>NODE_ENV=xxx</code>前面加上<code>cross-env</code></li>\n</ul>\n<p>这样就OK了。</p>"},{"title":"正则基础学习","date":"2017-07-20T06:38:42.000Z","_content":"\n\n正则表达式是一个威力巨大的处理字符串的工具，能够高效、神奇得完成对字符串的操作。相比较简单的字符串比较、查找、替换，正则表达式提供了更加强大的处理能力。正则表达式的价值就在于，不用正则来解决问题会让人疯掉，但是用了之后“纠结”的问题已不再是问题了。而且因为正则表达式用的不是一个固化的、具体的字符串来匹配字符串，而是抽象的模式的，所以只要正则写的规则没问题，一般都都能高效的完成任务。\n\n虽然正则表达式看起来确实很像外星文，就像变魔术一样，魔术本身也不神奇，只是的观众不解其中奥妙。学会了其中的规则，我们再去使用，肯定会发出感慨：神奇、复杂、好用。\n<!--more-->\n正则到底强在哪里呢？我们举个简单的例子：在一串包含数字以及英文字母的字符串中中找出数字并保存在数组中。代码如下：\n\n**不使用正则：**\n遍历字符串，利用字符串charAt()的方法将字符串中的数字检索出来，再push数组中，然后继续检索再push到数组中直到结束。\n````javascript\n    var str = '12 javascript 34 html5 33 php 77 css';\n    var arr = [];\n    var figure = '';\n    for(var i=0;i='0' && str.charAt(i)<='9'){\n            figure += str.charAt(i);\n        }else{\n            if(figure){\n            arr.push(tmp);\n            figure ='';\n        }\n    }\n}\nconsole.log(arr)//[ \"12\" , \"34\" , \"5\" , \"33\" , \"77\" ]\n````\n**而使用正则只需要如下短短的一行代码**：\n````javascript\nvar arr = str.match(/\\d+/g);\n````\n\n## 基础知识\n### 书写风格\n\njavascript中的正则是Perl5的正则表达式语法的大子集，所以在javascript中创建正则有js风格和petl风格两种。\n\n1. JS 风格： new RegExp('patten','ig')\n2. perl风格：/patten/ig\n\nJS风格其实就是通过RegExp对象来表示，而perl风格更普遍的叫法是RegExp直接量。这两个语法都是一样的，只是转义字符的写法不同。\n\n### 什么是正则\n正则表达式的结构与数学表达式很类似。\n\n一个数学表达式由若干个“项”组成，“项”与“项”之间用加号或减号相连\n\n为了方便理解，让我们先来看看大家一个典型的的数学表达式 `(x+3)*2+y`：\n\n这个数学表达式中`(x+3)*2`和`y`分别是两个项。每个项又由若干个__因子__组成，因子之间用乘号或除号相连。这里第一个项有两个因子`(x+3)`和`2`，而第二个项只有一个因子“y”。每个因子可以是一个简单的数，一个代数变量，也可以是放在括号里面的一个表达式，括号中的表达式称为__子表达式__。这里`x+3`就是一个子表达式。\n\n与数学表达式的__因子__相对应，构成正则表达式的部件称为__单位__；__项__则与正则表达式的子表达式相对应。而从逻辑上讲，子表达式之间是串接的关系，一个字符串必须与每个子表达式依次相匹配，才算与这个表达式相匹配。\n\n### 术语\n为了更好的学习正则，我们再来学习下正则表达式的一些术语\n\n1.  匹配（matching）\n    一个正则表达式“匹配”一个字符串，其实是指这个正则表达式能在字符串中找到匹配文本。\n\n2.  元字符（metacharacter）\n    只有在字符组外部并且是在未转义之前的情况下，才是一个元字符。\n\n3. 子表达式（subexpression）\n    子表达式指的一般是整个正则表达式中的一部分，通常是括号内的表达式，或者有|分隔的多选分支。子表达式由不可分割的单位组成。与多选分支不同的是，量词作用的对象是他们之前紧邻的子表达式。而如果量词之前紧邻的是一个括号保卫的自表达式，则不管其多么复杂都被视为一个单元。\n\n### 匹配模式\n上例中斜杠后面的 `ig`是匹配模式，可选的值有3个：`i`,`g`,`m`。其含义如下：\n\n- `i`：为 ignore case，即 忽略大小写。\n- `g`：为 global search，即全局搜索。\n- `m`：为 moltiline search，即多行搜索。\n\n所以，一个完整正则表达式是由一个个__子表达式__组成的，而__子表达式__则是由各种符号组成，这些符号按照功能可以分成以下类：转义字符、预定义特殊字符、字符类、量词、贪婪模式和非贪婪模式、匹配位置、分组、非捕获性分组、前瞻（零宽断言）。\n\n## 元字符组成部分\n### 转义字符\n什么是转义字符？在\\后面加字符就可以转义为特殊字符。\n\n例如： `\\n`匹配一个换行符， `\\\\`匹配“\\”。\n\n### 预定义特殊字符\n\n1. `\\o`:Nol字符。\n2. `\\t`:水平制表符。\n3. `\\v`:垂直制表符。\n4. `\\n`:换行符。\n5. `\\r`:回车符。\n6. `\\b`:退格符。 只有出现在字符中才有效，即[]（中括号）中。\n\n### 字符类\n1. `[ ]`:表示范围，一个字符的集合，匹配该集合中的任意一个字符，例如 `[abc]`就可以匹配\"css\"中的c；\n如果上例前面加 ^元字符，形如`[^asd]`，则表示匹配除了asd的其他字符；\n\n如果觉得匹配的字符太多，而且类型相似，则可以用-元字符表示，那么上例就可以这么写`[a-c]`这么写，所以上例也可以这么写 `[^a-d]`\n\n2. `\\w`和`\\W`:`\\w`表示匹配任何ASCII字符组成的单词，等价于[a-zA-Z0-9]；`\\W`表示匹配不是ASCII字符组成的单词等价于`[^a-zA-Z0-9]`。\n3. `\\s`和`\\S`:`\\s`匹配空白符，等价于`[\\t\\n\\x0B\\f\\r]`；`\\S`则匹配非空白字符，等价于`[^\\t\\n\\x0B\\f\\r]`。\n4. `\\d`和`\\D`:`\\d`匹配数字字符，等价于`[0-9]`；`\\D`匹配数字字符，等价于`[^0-9]`\n5. `.`:javascript有点特殊，由于浏览器的解析引擎不同，`.`的匹配范围也有所不同。\n    1. IE8以下：\n    .匹配所有除了换行符`/n`换行符之外的任意字符。等同于`[^\\n\\r]`\n\n    2. IE9以上以及其他浏览器\n    .匹配所有除了换行符`/n`换行符和回车符`\\r`之外的任意字符。等同于`[^\\n\\r]`\n\n````javascript\ndocument.write(/./.test(\"\\r\") + \"\");\ndocument.write(/./.test(\"\\n\") + \"\");\n/*IE8以下输出true false；IE9以上及其他浏览器输出 false false*/\n````\n\n### 量词\n\n首先我们得了解匹配量词都是匹配优先的，简单说就是匹配量词的结果总是尝试匹配尽可能多的字符，直到匹配上限为止，然后为了让整个表达式匹配成功，就需要“释放”之前优先匹配的字符，所以也被称为贪婪模式。\n\n而既然有贪婪模式，则一定也有非贪婪模式。\n\n对于贪婪模式和非贪婪模式影响的是被量词修饰的子表达式的匹配行为，既在贪婪模式下，在整个表达式匹配成功的前提下，尽可能多的匹配，而非贪婪模式在在整个表达式匹配成功的前提下，尽可能少的匹配。而且允许允许接下来的正则继续匹配。\n\n贪婪模式的量词，也叫简单量词，如下：\n\n`{n}`:n是一个正整数，表示前一个子表达式匹配n次。例如： /o{2}/匹配两次o，它可以匹配”footer“，但是不能匹配hot中的o。\n`{n,}`:n是一个正整数，表示前一个子表达式至少匹配n次。例如：/o{2,}/，它可以匹配“footer”，也可以匹配“fooooooooooter”。\n`{n,m}`:n、m都是正整数，表示至少匹配n次，至多m次。\n`?`:等价于{0,1}\n`+`:等价于{1,}\n`*`:等价于{0,}\n而在贪婪模式后加上 ?就变成了非贪婪模式。\n\n### 贪婪模式和非贪婪模式\n\n在上面提到的一个前提条件就是在整个表达式匹配成功，为什么要强调这个前提条件呢，看如下例子：\n\n````javascript\nvar pattern = 'aAaAaAb';\nconsole.log(/a+/i.exec(pattern)); //aAaAaA\nconsole.log(/a+?/i.exec(pattern)); //a\nconsole.log(/a+b/i.exec(pattern)); //aAaAaAb\nconsole.log(/a+?b/i.exec(pattern)); //aAaAaAb\n````\n\n全部是在忽略大小写的模式下：\n\n1. 第一个匹配结果解释：采用贪婪模式，在匹配第一个“a”时，整个表达式匹配成功了，由于采用了贪婪模式，所以仍然向右匹配，向右再也没有可以成功匹配的子字串，匹配结束，最终匹配结果为“aAaAaA”\n2. 第二个匹配结果解释：采用非贪婪模式，在匹配第一个“a”时，整个表达式匹配成功了，由于采用了非贪婪模式，所以结束匹配，最终匹配结果为“a。”\n3. 第三个匹配结果解释：采用贪婪模式，所以a+仍然可以匹配到“aAaAaA”，但是由于后面的 b无法匹配成功，所以为了让整个表达式匹配成功，a+必须让出前面的匹配内容，所以最终匹配结果为“aAaAaAb”。\n4. 第四个匹配结果解释：采用非贪婪模式，所以a+任然可以匹配到“a”，但是由于后面的 b无法匹配成功，所以为了让整个表达式匹配成功，a+必须继续匹配后面的直到“b”，所以最终匹配结果跟采用贪婪模式的匹配结果一样，也为“aAaAaAb”。\n5. \n所以，不管是贪婪模式还是非贪婪模式，都只有在整个表达式匹配成功的前提下量词才能影响字表达式的匹配行为。贪婪跟非贪婪模式主要功能是提高匹配效率，贪婪模式下可能会越过后面的正则，从而会导致匹配的回溯问题。所以在前面的正则坑会会越过后面的正则的情况下，请使用非贪婪模式。\n\n\n### 匹配位置\n\n前面说的量词是修饰子字符串的重复次数，而匹配位置则是来表示子字符串的出现位置，匹配的只是一个位置，所以是零宽度的。\n\n1. `^`:匹配文字的开头。如果正则表达式的匹配模式设置为','m'则也匹配每个换行符或者回车符之后的位置。\n2. `$`:匹配文字的开头。如果正则表达式的匹配模式设置为','m'则也匹配每个换行符或者回车符之前的位置。\n3. `/b`:匹配单词边界，不匹配任何字符。\n\n所谓的“单词”，就是位于\\w（ASCII单词）和\\W（非ASCII单词）之间的边界，或者位于ASCII单词与字符串开始或者结尾的合法位置。所以\\/bjava/b\\不匹配“javascript is more than java”中的javascript中java而只匹配之后的单词“java”。\n\n而因为javascript只支持ASCII字符不支持Unicode的，所以在javascript这门语言中\\w就可以等价于[a-zA-Z0-9]，也因为于此，javascript中\\w是不包括中文已经其他Unicode码特殊符号的，如下例子：\n\n````javascript\nvar str = \"html5_css3中文_h5$c3&汉字%\";\nconsole.log(str.match(/\\w+/g)); //\"html5_css3\" , \"_h5\" , \"c3\"\nconsole.log(str.match(/.\\b./g));//\"3中\" , \"文_\" , \"5$\" , \"3&\"\n````\n\n第一个例子中\\w+匹配了\"html5_css3\" , \"_h5\" , \"c3\"三个字符串，而其他的因为javascript只能匹配ASCII码的字符，所以除了字母、数字、“_“以及”$“的字符就都成单词的边界；而当使用.\\b.（除了换行符之外的任意字符，.匹配了那些\\w无法识别的Unicode码字符）匹配时，我们又得到\"3中\" , \"文_\" , \"5&\" ,说明这个字符串中有4个分界点5个子字符串，分别在\"3中\" , \"文_\" , \"5&\"之间，而四个子字符串分别是\"html5_css3\"，\"中文,\"_h5\",\"$c3\",\"&汉字%\"。\n\n所以，在处理一些字符串时，如果要使用\\b得先确认是否还有ASCII码的字符。\n\n注意：\\b在[]中表示退格。\n\n\n### 分组\n学习完以上的，应该会知道中括号用来限定字符类的范围，大括号则用来指定重复的次数，而小括号除了限制多选项的范围以及将若干字符组合为一个单位让量词能影响这个单元。还有一个用途就是，小括号能”记住“它们匹配成功的文本，在正则表达式的后面引用前面“记住”的匹配文本，通过 \\后加以为或者多位数字来实现，也就是“反向引用”。\n\n看实际例子吧：\n\n````javascript\n//1分组+量词\nconsole.log(/(js){2}/.test(\"jsjs\"));//true\n//2分组+范围\nconsole.log(/[JL]script/.test(\"Lscript\"));//true\n//3反向引用\nconsole.log(/([jJ])s\\1/.test(\"jsJs\"));//false\nconsole.log(/([jJ])s\\1/.test(\"jsjs\"));//true\n````\n\n例1和例2将括号内的若干字符组合为一个单位。而例3因为\\1引用的是之前匹配成功的字符串，所以例三中\\1就只能匹配”js“而不能匹配”Js“。\n\n然后介绍第二个分组的符号|。\n\n与小括号不同，小括号内的是一个整体（独立的子表达式），而|分割开的各分支是多选分支，即你可以选择|前面的也可以选择|后面的，如果有多个|隔开则是多选几。如下：\n\n````javascript\nvar reg = /(html5|css3|js)!!/;\nconsole.log(reg.test(\"html5!!\"));//true\nconsole.log(reg.test(\"css3!!\"));//true\nconsole.log(reg.test(\"js!!\"));//true\n````\n\n### 非捕获性分组\n\n对带圆括号的子表达式的引用确实强大，但是既然能够反向引用，正则引擎肯定是保存了括号内的一些信息。所以从效率角度来看，如果只是为了分组而不反向引用的话就采取非捕获性分组的方法。要创建一个非捕获性分组，只要在捕获性分组的左括号的后面紧跟一个问号与冒号就行了。\n\n从字面意思来看：非捕获分组能分组，但是不能捕获各个组的信息。如下：\n\n````javascript\nvar pattern1 = \"JS,HTML5,CSS\";\nconsole.log(pattern1.replace(/(\\w+),(?:\\w+)/, \"$2,$1\"));//$2,JS,CSS\n````\n\n### 前瞻\n\n前瞻也是属于零宽断言，说白了就是匹配位置的高级变体。前面我们说过的只是单纯的开头、结尾以及单词的边界，而前瞻的匹配则更加随意，如下：\n\n1. `(?=p)`:要求之后的字符必须与p匹配\n2. `(?!p)`:要求之后的字符必须不与p匹配\n\n如下实例：\n````javascript\nvar reg1 = /java(?!Scrit)/;\nvar reg2 = /java(?=Scrit)/;\nconsole.log(reg1.test(\"javaScrit\")); //false\nconsole.log(reg1.test(\"javaB\"));//true\nconsole.log(reg2.test(\"javaScrit\")); //true\nconsole.log(reg2.test(\"javaB\"));//false\n````\n\n前瞻的作用就是给正则增加一个附加条件，只有满足条件，才能继续走下去，前瞻匹配的结果是不纳入结果里的，只是一个条件。\n\n\n支持正则方法有支持正则的字符串方法和正则自身的方法\n\n## 支持正则表达式的 String 对象的方法\n### 字符串搜索：\n`search()`方法用于检索字符串中指定的子字符串，返回匹配的字符的位置（0-~）。\n\n如果没有找到匹配的字符，则返回-1；将忽略RegExp中的全局模式，只返回第一个匹配的位置。\n\n````javascript\nvar pattern = \"hello html5 js css\";\nconsole.log(pattern.search(/Html5/i));//6\n````\n\n### 字符串匹配：\n\n`match()`方法可以返回匹配结果的数组，并且依赖于regexp的全局标志g。如果没有全局标志g，则只匹配一次；如果有，则匹配多次直到结束，最后返回一个存有匹配匹配文本的数组。\n\n`match()`即不提供与子表达式匹配的文本的信息，也不声明每个匹配子串的索引位置。如果您需要这些信息，可以使用 RegExp.exec()。\n\n````javascript\nvar pattern=\"2012 years 12 month 20 is the end of the world\";\nconsole.log(pattern.match(/\\d+/g));//[\"2012\",\"12\",\"20\"]\n````\n\n### 字符串替代：\n\n`replace()`方法用于替换字符串或者正则表达式匹配的子字符串，并且也依赖于regexp的全局标志g。如果没有全局标志g，则只替换第一个匹配的子字符串；如果有，则替换所有匹配的子字符串。\n\n`replace()`的第二个参数可以是字符串，也可以是函数。如果是字符串，则由每个匹配的字符串替换，其中 $ 具有特殊的含义：\n\n1. `$n`：其中n表示1-99，表示匹配的子字符串中的第n个，n就是带圆括号的子表达式的位置。\n2. `$&`：全部匹配的子字符串\n3. `$``：匹配子串左侧的文本\n4. `$'`：匹配子串右侧的文本\n\n````javascript\nvar pattern1 = \"JS,HTML5,CSS\";\nvar replace1 = pattern1.replace(/(\\w{1,}),(\\w+)/, \"$2,$1\");\nconsole.log(replace1);//HTML5,JS,CSS\nvar replace2 = pattern1.replace(/(\\w+),/g,\"$1-\");\nconsole.log(replace2);//JS-HTML5-CSS\n````\n\n### 字符串分割：\n\n`split()`方法用于把一个字符串分割成字符串数组。该方法有两个参数，第一个参数是指定分割的边界；第二个参数是指定返回数组的长度，如果没有则字符串之间的都会被分割。\n\n若使用 `split(\"\")` 则会将单词分割成字母\n````javascript\nvar pattern = \"HTML5 JS CSS\";\nvar sWord1 = pattern.split(\" \");\nvar sWord2 = pattern.split(\"\");\nconsole.log(sWord1);//[ \"HTML5\" , \"JS\" , \"CSS\" ]\nconsole.log(sWord2);//[ \"H\" , \"T\" , \"M\" , \"L\" , \"5\" , \" \" , \"J\" , \"S\" , \" \" , \"C\" , \"S\" , \"S\"]\n````\n\n## RegExp 对象的方法\n## test：\n\ntest()方法用于检索要检测的字符串是否存在，若含有与regExp相匹配的文本，则返回true，否则返回false\n\n## exec：\nexec()方法用于匹配字串，跟不是全局的match()方法很类似，但是它不仅能检索字符串中指定的值，返回找到的值，还能确定其位置。 比match()强大。如果利用 exec() 的lastIndex属性反复调用同样可以模拟match()全局检索字符串的效果。","source":"_posts/javascript-reg-1.md","raw":"title: 正则基础学习\ndate: 2017-07-20 14:38:42\ntags: \n- JavaScript\n- 正则\ncategories:\n- JavaScript\n---\n\n\n正则表达式是一个威力巨大的处理字符串的工具，能够高效、神奇得完成对字符串的操作。相比较简单的字符串比较、查找、替换，正则表达式提供了更加强大的处理能力。正则表达式的价值就在于，不用正则来解决问题会让人疯掉，但是用了之后“纠结”的问题已不再是问题了。而且因为正则表达式用的不是一个固化的、具体的字符串来匹配字符串，而是抽象的模式的，所以只要正则写的规则没问题，一般都都能高效的完成任务。\n\n虽然正则表达式看起来确实很像外星文，就像变魔术一样，魔术本身也不神奇，只是的观众不解其中奥妙。学会了其中的规则，我们再去使用，肯定会发出感慨：神奇、复杂、好用。\n<!--more-->\n正则到底强在哪里呢？我们举个简单的例子：在一串包含数字以及英文字母的字符串中中找出数字并保存在数组中。代码如下：\n\n**不使用正则：**\n遍历字符串，利用字符串charAt()的方法将字符串中的数字检索出来，再push数组中，然后继续检索再push到数组中直到结束。\n````javascript\n    var str = '12 javascript 34 html5 33 php 77 css';\n    var arr = [];\n    var figure = '';\n    for(var i=0;i='0' && str.charAt(i)<='9'){\n            figure += str.charAt(i);\n        }else{\n            if(figure){\n            arr.push(tmp);\n            figure ='';\n        }\n    }\n}\nconsole.log(arr)//[ \"12\" , \"34\" , \"5\" , \"33\" , \"77\" ]\n````\n**而使用正则只需要如下短短的一行代码**：\n````javascript\nvar arr = str.match(/\\d+/g);\n````\n\n## 基础知识\n### 书写风格\n\njavascript中的正则是Perl5的正则表达式语法的大子集，所以在javascript中创建正则有js风格和petl风格两种。\n\n1. JS 风格： new RegExp('patten','ig')\n2. perl风格：/patten/ig\n\nJS风格其实就是通过RegExp对象来表示，而perl风格更普遍的叫法是RegExp直接量。这两个语法都是一样的，只是转义字符的写法不同。\n\n### 什么是正则\n正则表达式的结构与数学表达式很类似。\n\n一个数学表达式由若干个“项”组成，“项”与“项”之间用加号或减号相连\n\n为了方便理解，让我们先来看看大家一个典型的的数学表达式 `(x+3)*2+y`：\n\n这个数学表达式中`(x+3)*2`和`y`分别是两个项。每个项又由若干个__因子__组成，因子之间用乘号或除号相连。这里第一个项有两个因子`(x+3)`和`2`，而第二个项只有一个因子“y”。每个因子可以是一个简单的数，一个代数变量，也可以是放在括号里面的一个表达式，括号中的表达式称为__子表达式__。这里`x+3`就是一个子表达式。\n\n与数学表达式的__因子__相对应，构成正则表达式的部件称为__单位__；__项__则与正则表达式的子表达式相对应。而从逻辑上讲，子表达式之间是串接的关系，一个字符串必须与每个子表达式依次相匹配，才算与这个表达式相匹配。\n\n### 术语\n为了更好的学习正则，我们再来学习下正则表达式的一些术语\n\n1.  匹配（matching）\n    一个正则表达式“匹配”一个字符串，其实是指这个正则表达式能在字符串中找到匹配文本。\n\n2.  元字符（metacharacter）\n    只有在字符组外部并且是在未转义之前的情况下，才是一个元字符。\n\n3. 子表达式（subexpression）\n    子表达式指的一般是整个正则表达式中的一部分，通常是括号内的表达式，或者有|分隔的多选分支。子表达式由不可分割的单位组成。与多选分支不同的是，量词作用的对象是他们之前紧邻的子表达式。而如果量词之前紧邻的是一个括号保卫的自表达式，则不管其多么复杂都被视为一个单元。\n\n### 匹配模式\n上例中斜杠后面的 `ig`是匹配模式，可选的值有3个：`i`,`g`,`m`。其含义如下：\n\n- `i`：为 ignore case，即 忽略大小写。\n- `g`：为 global search，即全局搜索。\n- `m`：为 moltiline search，即多行搜索。\n\n所以，一个完整正则表达式是由一个个__子表达式__组成的，而__子表达式__则是由各种符号组成，这些符号按照功能可以分成以下类：转义字符、预定义特殊字符、字符类、量词、贪婪模式和非贪婪模式、匹配位置、分组、非捕获性分组、前瞻（零宽断言）。\n\n## 元字符组成部分\n### 转义字符\n什么是转义字符？在\\后面加字符就可以转义为特殊字符。\n\n例如： `\\n`匹配一个换行符， `\\\\`匹配“\\”。\n\n### 预定义特殊字符\n\n1. `\\o`:Nol字符。\n2. `\\t`:水平制表符。\n3. `\\v`:垂直制表符。\n4. `\\n`:换行符。\n5. `\\r`:回车符。\n6. `\\b`:退格符。 只有出现在字符中才有效，即[]（中括号）中。\n\n### 字符类\n1. `[ ]`:表示范围，一个字符的集合，匹配该集合中的任意一个字符，例如 `[abc]`就可以匹配\"css\"中的c；\n如果上例前面加 ^元字符，形如`[^asd]`，则表示匹配除了asd的其他字符；\n\n如果觉得匹配的字符太多，而且类型相似，则可以用-元字符表示，那么上例就可以这么写`[a-c]`这么写，所以上例也可以这么写 `[^a-d]`\n\n2. `\\w`和`\\W`:`\\w`表示匹配任何ASCII字符组成的单词，等价于[a-zA-Z0-9]；`\\W`表示匹配不是ASCII字符组成的单词等价于`[^a-zA-Z0-9]`。\n3. `\\s`和`\\S`:`\\s`匹配空白符，等价于`[\\t\\n\\x0B\\f\\r]`；`\\S`则匹配非空白字符，等价于`[^\\t\\n\\x0B\\f\\r]`。\n4. `\\d`和`\\D`:`\\d`匹配数字字符，等价于`[0-9]`；`\\D`匹配数字字符，等价于`[^0-9]`\n5. `.`:javascript有点特殊，由于浏览器的解析引擎不同，`.`的匹配范围也有所不同。\n    1. IE8以下：\n    .匹配所有除了换行符`/n`换行符之外的任意字符。等同于`[^\\n\\r]`\n\n    2. IE9以上以及其他浏览器\n    .匹配所有除了换行符`/n`换行符和回车符`\\r`之外的任意字符。等同于`[^\\n\\r]`\n\n````javascript\ndocument.write(/./.test(\"\\r\") + \"\");\ndocument.write(/./.test(\"\\n\") + \"\");\n/*IE8以下输出true false；IE9以上及其他浏览器输出 false false*/\n````\n\n### 量词\n\n首先我们得了解匹配量词都是匹配优先的，简单说就是匹配量词的结果总是尝试匹配尽可能多的字符，直到匹配上限为止，然后为了让整个表达式匹配成功，就需要“释放”之前优先匹配的字符，所以也被称为贪婪模式。\n\n而既然有贪婪模式，则一定也有非贪婪模式。\n\n对于贪婪模式和非贪婪模式影响的是被量词修饰的子表达式的匹配行为，既在贪婪模式下，在整个表达式匹配成功的前提下，尽可能多的匹配，而非贪婪模式在在整个表达式匹配成功的前提下，尽可能少的匹配。而且允许允许接下来的正则继续匹配。\n\n贪婪模式的量词，也叫简单量词，如下：\n\n`{n}`:n是一个正整数，表示前一个子表达式匹配n次。例如： /o{2}/匹配两次o，它可以匹配”footer“，但是不能匹配hot中的o。\n`{n,}`:n是一个正整数，表示前一个子表达式至少匹配n次。例如：/o{2,}/，它可以匹配“footer”，也可以匹配“fooooooooooter”。\n`{n,m}`:n、m都是正整数，表示至少匹配n次，至多m次。\n`?`:等价于{0,1}\n`+`:等价于{1,}\n`*`:等价于{0,}\n而在贪婪模式后加上 ?就变成了非贪婪模式。\n\n### 贪婪模式和非贪婪模式\n\n在上面提到的一个前提条件就是在整个表达式匹配成功，为什么要强调这个前提条件呢，看如下例子：\n\n````javascript\nvar pattern = 'aAaAaAb';\nconsole.log(/a+/i.exec(pattern)); //aAaAaA\nconsole.log(/a+?/i.exec(pattern)); //a\nconsole.log(/a+b/i.exec(pattern)); //aAaAaAb\nconsole.log(/a+?b/i.exec(pattern)); //aAaAaAb\n````\n\n全部是在忽略大小写的模式下：\n\n1. 第一个匹配结果解释：采用贪婪模式，在匹配第一个“a”时，整个表达式匹配成功了，由于采用了贪婪模式，所以仍然向右匹配，向右再也没有可以成功匹配的子字串，匹配结束，最终匹配结果为“aAaAaA”\n2. 第二个匹配结果解释：采用非贪婪模式，在匹配第一个“a”时，整个表达式匹配成功了，由于采用了非贪婪模式，所以结束匹配，最终匹配结果为“a。”\n3. 第三个匹配结果解释：采用贪婪模式，所以a+仍然可以匹配到“aAaAaA”，但是由于后面的 b无法匹配成功，所以为了让整个表达式匹配成功，a+必须让出前面的匹配内容，所以最终匹配结果为“aAaAaAb”。\n4. 第四个匹配结果解释：采用非贪婪模式，所以a+任然可以匹配到“a”，但是由于后面的 b无法匹配成功，所以为了让整个表达式匹配成功，a+必须继续匹配后面的直到“b”，所以最终匹配结果跟采用贪婪模式的匹配结果一样，也为“aAaAaAb”。\n5. \n所以，不管是贪婪模式还是非贪婪模式，都只有在整个表达式匹配成功的前提下量词才能影响字表达式的匹配行为。贪婪跟非贪婪模式主要功能是提高匹配效率，贪婪模式下可能会越过后面的正则，从而会导致匹配的回溯问题。所以在前面的正则坑会会越过后面的正则的情况下，请使用非贪婪模式。\n\n\n### 匹配位置\n\n前面说的量词是修饰子字符串的重复次数，而匹配位置则是来表示子字符串的出现位置，匹配的只是一个位置，所以是零宽度的。\n\n1. `^`:匹配文字的开头。如果正则表达式的匹配模式设置为','m'则也匹配每个换行符或者回车符之后的位置。\n2. `$`:匹配文字的开头。如果正则表达式的匹配模式设置为','m'则也匹配每个换行符或者回车符之前的位置。\n3. `/b`:匹配单词边界，不匹配任何字符。\n\n所谓的“单词”，就是位于\\w（ASCII单词）和\\W（非ASCII单词）之间的边界，或者位于ASCII单词与字符串开始或者结尾的合法位置。所以\\/bjava/b\\不匹配“javascript is more than java”中的javascript中java而只匹配之后的单词“java”。\n\n而因为javascript只支持ASCII字符不支持Unicode的，所以在javascript这门语言中\\w就可以等价于[a-zA-Z0-9]，也因为于此，javascript中\\w是不包括中文已经其他Unicode码特殊符号的，如下例子：\n\n````javascript\nvar str = \"html5_css3中文_h5$c3&汉字%\";\nconsole.log(str.match(/\\w+/g)); //\"html5_css3\" , \"_h5\" , \"c3\"\nconsole.log(str.match(/.\\b./g));//\"3中\" , \"文_\" , \"5$\" , \"3&\"\n````\n\n第一个例子中\\w+匹配了\"html5_css3\" , \"_h5\" , \"c3\"三个字符串，而其他的因为javascript只能匹配ASCII码的字符，所以除了字母、数字、“_“以及”$“的字符就都成单词的边界；而当使用.\\b.（除了换行符之外的任意字符，.匹配了那些\\w无法识别的Unicode码字符）匹配时，我们又得到\"3中\" , \"文_\" , \"5&\" ,说明这个字符串中有4个分界点5个子字符串，分别在\"3中\" , \"文_\" , \"5&\"之间，而四个子字符串分别是\"html5_css3\"，\"中文,\"_h5\",\"$c3\",\"&汉字%\"。\n\n所以，在处理一些字符串时，如果要使用\\b得先确认是否还有ASCII码的字符。\n\n注意：\\b在[]中表示退格。\n\n\n### 分组\n学习完以上的，应该会知道中括号用来限定字符类的范围，大括号则用来指定重复的次数，而小括号除了限制多选项的范围以及将若干字符组合为一个单位让量词能影响这个单元。还有一个用途就是，小括号能”记住“它们匹配成功的文本，在正则表达式的后面引用前面“记住”的匹配文本，通过 \\后加以为或者多位数字来实现，也就是“反向引用”。\n\n看实际例子吧：\n\n````javascript\n//1分组+量词\nconsole.log(/(js){2}/.test(\"jsjs\"));//true\n//2分组+范围\nconsole.log(/[JL]script/.test(\"Lscript\"));//true\n//3反向引用\nconsole.log(/([jJ])s\\1/.test(\"jsJs\"));//false\nconsole.log(/([jJ])s\\1/.test(\"jsjs\"));//true\n````\n\n例1和例2将括号内的若干字符组合为一个单位。而例3因为\\1引用的是之前匹配成功的字符串，所以例三中\\1就只能匹配”js“而不能匹配”Js“。\n\n然后介绍第二个分组的符号|。\n\n与小括号不同，小括号内的是一个整体（独立的子表达式），而|分割开的各分支是多选分支，即你可以选择|前面的也可以选择|后面的，如果有多个|隔开则是多选几。如下：\n\n````javascript\nvar reg = /(html5|css3|js)!!/;\nconsole.log(reg.test(\"html5!!\"));//true\nconsole.log(reg.test(\"css3!!\"));//true\nconsole.log(reg.test(\"js!!\"));//true\n````\n\n### 非捕获性分组\n\n对带圆括号的子表达式的引用确实强大，但是既然能够反向引用，正则引擎肯定是保存了括号内的一些信息。所以从效率角度来看，如果只是为了分组而不反向引用的话就采取非捕获性分组的方法。要创建一个非捕获性分组，只要在捕获性分组的左括号的后面紧跟一个问号与冒号就行了。\n\n从字面意思来看：非捕获分组能分组，但是不能捕获各个组的信息。如下：\n\n````javascript\nvar pattern1 = \"JS,HTML5,CSS\";\nconsole.log(pattern1.replace(/(\\w+),(?:\\w+)/, \"$2,$1\"));//$2,JS,CSS\n````\n\n### 前瞻\n\n前瞻也是属于零宽断言，说白了就是匹配位置的高级变体。前面我们说过的只是单纯的开头、结尾以及单词的边界，而前瞻的匹配则更加随意，如下：\n\n1. `(?=p)`:要求之后的字符必须与p匹配\n2. `(?!p)`:要求之后的字符必须不与p匹配\n\n如下实例：\n````javascript\nvar reg1 = /java(?!Scrit)/;\nvar reg2 = /java(?=Scrit)/;\nconsole.log(reg1.test(\"javaScrit\")); //false\nconsole.log(reg1.test(\"javaB\"));//true\nconsole.log(reg2.test(\"javaScrit\")); //true\nconsole.log(reg2.test(\"javaB\"));//false\n````\n\n前瞻的作用就是给正则增加一个附加条件，只有满足条件，才能继续走下去，前瞻匹配的结果是不纳入结果里的，只是一个条件。\n\n\n支持正则方法有支持正则的字符串方法和正则自身的方法\n\n## 支持正则表达式的 String 对象的方法\n### 字符串搜索：\n`search()`方法用于检索字符串中指定的子字符串，返回匹配的字符的位置（0-~）。\n\n如果没有找到匹配的字符，则返回-1；将忽略RegExp中的全局模式，只返回第一个匹配的位置。\n\n````javascript\nvar pattern = \"hello html5 js css\";\nconsole.log(pattern.search(/Html5/i));//6\n````\n\n### 字符串匹配：\n\n`match()`方法可以返回匹配结果的数组，并且依赖于regexp的全局标志g。如果没有全局标志g，则只匹配一次；如果有，则匹配多次直到结束，最后返回一个存有匹配匹配文本的数组。\n\n`match()`即不提供与子表达式匹配的文本的信息，也不声明每个匹配子串的索引位置。如果您需要这些信息，可以使用 RegExp.exec()。\n\n````javascript\nvar pattern=\"2012 years 12 month 20 is the end of the world\";\nconsole.log(pattern.match(/\\d+/g));//[\"2012\",\"12\",\"20\"]\n````\n\n### 字符串替代：\n\n`replace()`方法用于替换字符串或者正则表达式匹配的子字符串，并且也依赖于regexp的全局标志g。如果没有全局标志g，则只替换第一个匹配的子字符串；如果有，则替换所有匹配的子字符串。\n\n`replace()`的第二个参数可以是字符串，也可以是函数。如果是字符串，则由每个匹配的字符串替换，其中 $ 具有特殊的含义：\n\n1. `$n`：其中n表示1-99，表示匹配的子字符串中的第n个，n就是带圆括号的子表达式的位置。\n2. `$&`：全部匹配的子字符串\n3. `$``：匹配子串左侧的文本\n4. `$'`：匹配子串右侧的文本\n\n````javascript\nvar pattern1 = \"JS,HTML5,CSS\";\nvar replace1 = pattern1.replace(/(\\w{1,}),(\\w+)/, \"$2,$1\");\nconsole.log(replace1);//HTML5,JS,CSS\nvar replace2 = pattern1.replace(/(\\w+),/g,\"$1-\");\nconsole.log(replace2);//JS-HTML5-CSS\n````\n\n### 字符串分割：\n\n`split()`方法用于把一个字符串分割成字符串数组。该方法有两个参数，第一个参数是指定分割的边界；第二个参数是指定返回数组的长度，如果没有则字符串之间的都会被分割。\n\n若使用 `split(\"\")` 则会将单词分割成字母\n````javascript\nvar pattern = \"HTML5 JS CSS\";\nvar sWord1 = pattern.split(\" \");\nvar sWord2 = pattern.split(\"\");\nconsole.log(sWord1);//[ \"HTML5\" , \"JS\" , \"CSS\" ]\nconsole.log(sWord2);//[ \"H\" , \"T\" , \"M\" , \"L\" , \"5\" , \" \" , \"J\" , \"S\" , \" \" , \"C\" , \"S\" , \"S\"]\n````\n\n## RegExp 对象的方法\n## test：\n\ntest()方法用于检索要检测的字符串是否存在，若含有与regExp相匹配的文本，则返回true，否则返回false\n\n## exec：\nexec()方法用于匹配字串，跟不是全局的match()方法很类似，但是它不仅能检索字符串中指定的值，返回找到的值，还能确定其位置。 比match()强大。如果利用 exec() 的lastIndex属性反复调用同样可以模拟match()全局检索字符串的效果。","slug":"javascript-reg-1","published":1,"updated":"2017-07-31T08:33:47.264Z","_id":"cj5rrqje30006fkf1vnjudpud","comments":1,"layout":"post","photos":[],"link":"","content":"<p>正则表达式是一个威力巨大的处理字符串的工具，能够高效、神奇得完成对字符串的操作。相比较简单的字符串比较、查找、替换，正则表达式提供了更加强大的处理能力。正则表达式的价值就在于，不用正则来解决问题会让人疯掉，但是用了之后“纠结”的问题已不再是问题了。而且因为正则表达式用的不是一个固化的、具体的字符串来匹配字符串，而是抽象的模式的，所以只要正则写的规则没问题，一般都都能高效的完成任务。</p>\n<p>虽然正则表达式看起来确实很像外星文，就像变魔术一样，魔术本身也不神奇，只是的观众不解其中奥妙。学会了其中的规则，我们再去使用，肯定会发出感慨：神奇、复杂、好用。<br><a id=\"more\"></a><br>正则到底强在哪里呢？我们举个简单的例子：在一串包含数字以及英文字母的字符串中中找出数字并保存在数组中。代码如下：</p>\n<p><strong>不使用正则：</strong><br>遍历字符串，利用字符串charAt()的方法将字符串中的数字检索出来，再push数组中，然后继续检索再push到数组中直到结束。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">var</span> str = <span class=\"string\">'12 javascript 34 html5 33 php 77 css'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> arr = [];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> figure = <span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i=<span class=\"string\">'0'</span> &amp;&amp; str.charAt(i)&lt;=<span class=\"string\">'9'</span>)&#123;</span><br><span class=\"line\">            figure += str.charAt(i);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(figure)&#123;</span><br><span class=\"line\">            arr.push(tmp);</span><br><span class=\"line\">            figure =<span class=\"string\">''</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr)<span class=\"comment\">//[ \"12\" , \"34\" , \"5\" , \"33\" , \"77\" ]</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>而使用正则只需要如下短短的一行代码</strong>：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = str.match(<span class=\"regexp\">/\\d+/g</span>);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><h3 id=\"书写风格\"><a href=\"#书写风格\" class=\"headerlink\" title=\"书写风格\"></a>书写风格</h3><p>javascript中的正则是Perl5的正则表达式语法的大子集，所以在javascript中创建正则有js风格和petl风格两种。</p>\n<ol>\n<li>JS 风格： new RegExp(‘patten’,’ig’)</li>\n<li>perl风格：/patten/ig</li>\n</ol>\n<p>JS风格其实就是通过RegExp对象来表示，而perl风格更普遍的叫法是RegExp直接量。这两个语法都是一样的，只是转义字符的写法不同。</p>\n<h3 id=\"什么是正则\"><a href=\"#什么是正则\" class=\"headerlink\" title=\"什么是正则\"></a>什么是正则</h3><p>正则表达式的结构与数学表达式很类似。</p>\n<p>一个数学表达式由若干个“项”组成，“项”与“项”之间用加号或减号相连</p>\n<p>为了方便理解，让我们先来看看大家一个典型的的数学表达式 <code>(x+3)*2+y</code>：</p>\n<p>这个数学表达式中<code>(x+3)*2</code>和<code>y</code>分别是两个项。每个项又由若干个<strong>因子</strong>组成，因子之间用乘号或除号相连。这里第一个项有两个因子<code>(x+3)</code>和<code>2</code>，而第二个项只有一个因子“y”。每个因子可以是一个简单的数，一个代数变量，也可以是放在括号里面的一个表达式，括号中的表达式称为<strong>子表达式</strong>。这里<code>x+3</code>就是一个子表达式。</p>\n<p>与数学表达式的<strong>因子</strong>相对应，构成正则表达式的部件称为<strong>单位</strong>；<strong>项</strong>则与正则表达式的子表达式相对应。而从逻辑上讲，子表达式之间是串接的关系，一个字符串必须与每个子表达式依次相匹配，才算与这个表达式相匹配。</p>\n<h3 id=\"术语\"><a href=\"#术语\" class=\"headerlink\" title=\"术语\"></a>术语</h3><p>为了更好的学习正则，我们再来学习下正则表达式的一些术语</p>\n<ol>\n<li><p>匹配（matching）<br>一个正则表达式“匹配”一个字符串，其实是指这个正则表达式能在字符串中找到匹配文本。</p>\n</li>\n<li><p>元字符（metacharacter）<br>只有在字符组外部并且是在未转义之前的情况下，才是一个元字符。</p>\n</li>\n<li><p>子表达式（subexpression）<br> 子表达式指的一般是整个正则表达式中的一部分，通常是括号内的表达式，或者有|分隔的多选分支。子表达式由不可分割的单位组成。与多选分支不同的是，量词作用的对象是他们之前紧邻的子表达式。而如果量词之前紧邻的是一个括号保卫的自表达式，则不管其多么复杂都被视为一个单元。</p>\n</li>\n</ol>\n<h3 id=\"匹配模式\"><a href=\"#匹配模式\" class=\"headerlink\" title=\"匹配模式\"></a>匹配模式</h3><p>上例中斜杠后面的 <code>ig</code>是匹配模式，可选的值有3个：<code>i</code>,<code>g</code>,<code>m</code>。其含义如下：</p>\n<ul>\n<li><code>i</code>：为 ignore case，即 忽略大小写。</li>\n<li><code>g</code>：为 global search，即全局搜索。</li>\n<li><code>m</code>：为 moltiline search，即多行搜索。</li>\n</ul>\n<p>所以，一个完整正则表达式是由一个个<strong>子表达式</strong>组成的，而<strong>子表达式</strong>则是由各种符号组成，这些符号按照功能可以分成以下类：转义字符、预定义特殊字符、字符类、量词、贪婪模式和非贪婪模式、匹配位置、分组、非捕获性分组、前瞻（零宽断言）。</p>\n<h2 id=\"元字符组成部分\"><a href=\"#元字符组成部分\" class=\"headerlink\" title=\"元字符组成部分\"></a>元字符组成部分</h2><h3 id=\"转义字符\"><a href=\"#转义字符\" class=\"headerlink\" title=\"转义字符\"></a>转义字符</h3><p>什么是转义字符？在\\后面加字符就可以转义为特殊字符。</p>\n<p>例如： <code>\\n</code>匹配一个换行符， <code>\\\\</code>匹配“\\”。</p>\n<h3 id=\"预定义特殊字符\"><a href=\"#预定义特殊字符\" class=\"headerlink\" title=\"预定义特殊字符\"></a>预定义特殊字符</h3><ol>\n<li><code>\\o</code>:Nol字符。</li>\n<li><code>\\t</code>:水平制表符。</li>\n<li><code>\\v</code>:垂直制表符。</li>\n<li><code>\\n</code>:换行符。</li>\n<li><code>\\r</code>:回车符。</li>\n<li><code>\\b</code>:退格符。 只有出现在字符中才有效，即[]（中括号）中。</li>\n</ol>\n<h3 id=\"字符类\"><a href=\"#字符类\" class=\"headerlink\" title=\"字符类\"></a>字符类</h3><ol>\n<li><code>[ ]</code>:表示范围，一个字符的集合，匹配该集合中的任意一个字符，例如 <code>[abc]</code>就可以匹配”css”中的c；<br>如果上例前面加 ^元字符，形如<code>[^asd]</code>，则表示匹配除了asd的其他字符；</li>\n</ol>\n<p>如果觉得匹配的字符太多，而且类型相似，则可以用-元字符表示，那么上例就可以这么写<code>[a-c]</code>这么写，所以上例也可以这么写 <code>[^a-d]</code></p>\n<ol>\n<li><code>\\w</code>和<code>\\W</code>:<code>\\w</code>表示匹配任何ASCII字符组成的单词，等价于[a-zA-Z0-9]；<code>\\W</code>表示匹配不是ASCII字符组成的单词等价于<code>[^a-zA-Z0-9]</code>。</li>\n<li><code>\\s</code>和<code>\\S</code>:<code>\\s</code>匹配空白符，等价于<code>[\\t\\n\\x0B\\f\\r]</code>；<code>\\S</code>则匹配非空白字符，等价于<code>[^\\t\\n\\x0B\\f\\r]</code>。</li>\n<li><code>\\d</code>和<code>\\D</code>:<code>\\d</code>匹配数字字符，等价于<code>[0-9]</code>；<code>\\D</code>匹配数字字符，等价于<code>[^0-9]</code></li>\n<li><p><code>.</code>:javascript有点特殊，由于浏览器的解析引擎不同，<code>.</code>的匹配范围也有所不同。</p>\n<ol>\n<li><p>IE8以下：<br>.匹配所有除了换行符<code>/n</code>换行符之外的任意字符。等同于<code>[^\\n\\r]</code></p>\n</li>\n<li><p>IE9以上以及其他浏览器<br>.匹配所有除了换行符<code>/n</code>换行符和回车符<code>\\r</code>之外的任意字符。等同于<code>[^\\n\\r]</code></p>\n</li>\n</ol>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"regexp\">/./</span>.test(<span class=\"string\">\"\\r\"</span>) + <span class=\"string\">\"\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"regexp\">/./</span>.test(<span class=\"string\">\"\\n\"</span>) + <span class=\"string\">\"\"</span>);</span><br><span class=\"line\"><span class=\"comment\">/*IE8以下输出true false；IE9以上及其他浏览器输出 false false*/</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"量词\"><a href=\"#量词\" class=\"headerlink\" title=\"量词\"></a>量词</h3><p>首先我们得了解匹配量词都是匹配优先的，简单说就是匹配量词的结果总是尝试匹配尽可能多的字符，直到匹配上限为止，然后为了让整个表达式匹配成功，就需要“释放”之前优先匹配的字符，所以也被称为贪婪模式。</p>\n<p>而既然有贪婪模式，则一定也有非贪婪模式。</p>\n<p>对于贪婪模式和非贪婪模式影响的是被量词修饰的子表达式的匹配行为，既在贪婪模式下，在整个表达式匹配成功的前提下，尽可能多的匹配，而非贪婪模式在在整个表达式匹配成功的前提下，尽可能少的匹配。而且允许允许接下来的正则继续匹配。</p>\n<p>贪婪模式的量词，也叫简单量词，如下：</p>\n<p><code>{n}</code>:n是一个正整数，表示前一个子表达式匹配n次。例如： /o{2}/匹配两次o，它可以匹配”footer“，但是不能匹配hot中的o。<br><code>{n,}</code>:n是一个正整数，表示前一个子表达式至少匹配n次。例如：/o{2,}/，它可以匹配“footer”，也可以匹配“fooooooooooter”。<br><code>{n,m}</code>:n、m都是正整数，表示至少匹配n次，至多m次。<br><code>?</code>:等价于{0,1}<br><code>+</code>:等价于{1,}<br><code>*</code>:等价于{0,}<br>而在贪婪模式后加上 ?就变成了非贪婪模式。</p>\n<h3 id=\"贪婪模式和非贪婪模式\"><a href=\"#贪婪模式和非贪婪模式\" class=\"headerlink\" title=\"贪婪模式和非贪婪模式\"></a>贪婪模式和非贪婪模式</h3><p>在上面提到的一个前提条件就是在整个表达式匹配成功，为什么要强调这个前提条件呢，看如下例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> pattern = <span class=\"string\">'aAaAaAb'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"regexp\">/a+/i</span>.exec(pattern)); <span class=\"comment\">//aAaAaA</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"regexp\">/a+?/i</span>.exec(pattern)); <span class=\"comment\">//a</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"regexp\">/a+b/i</span>.exec(pattern)); <span class=\"comment\">//aAaAaAb</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"regexp\">/a+?b/i</span>.exec(pattern)); <span class=\"comment\">//aAaAaAb</span></span><br></pre></td></tr></table></figure>\n<p>全部是在忽略大小写的模式下：</p>\n<ol>\n<li>第一个匹配结果解释：采用贪婪模式，在匹配第一个“a”时，整个表达式匹配成功了，由于采用了贪婪模式，所以仍然向右匹配，向右再也没有可以成功匹配的子字串，匹配结束，最终匹配结果为“aAaAaA”</li>\n<li>第二个匹配结果解释：采用非贪婪模式，在匹配第一个“a”时，整个表达式匹配成功了，由于采用了非贪婪模式，所以结束匹配，最终匹配结果为“a。”</li>\n<li>第三个匹配结果解释：采用贪婪模式，所以a+仍然可以匹配到“aAaAaA”，但是由于后面的 b无法匹配成功，所以为了让整个表达式匹配成功，a+必须让出前面的匹配内容，所以最终匹配结果为“aAaAaAb”。</li>\n<li>第四个匹配结果解释：采用非贪婪模式，所以a+任然可以匹配到“a”，但是由于后面的 b无法匹配成功，所以为了让整个表达式匹配成功，a+必须继续匹配后面的直到“b”，所以最终匹配结果跟采用贪婪模式的匹配结果一样，也为“aAaAaAb”。</li>\n<li>所以，不管是贪婪模式还是非贪婪模式，都只有在整个表达式匹配成功的前提下量词才能影响字表达式的匹配行为。贪婪跟非贪婪模式主要功能是提高匹配效率，贪婪模式下可能会越过后面的正则，从而会导致匹配的回溯问题。所以在前面的正则坑会会越过后面的正则的情况下，请使用非贪婪模式。</li>\n</ol>\n<h3 id=\"匹配位置\"><a href=\"#匹配位置\" class=\"headerlink\" title=\"匹配位置\"></a>匹配位置</h3><p>前面说的量词是修饰子字符串的重复次数，而匹配位置则是来表示子字符串的出现位置，匹配的只是一个位置，所以是零宽度的。</p>\n<ol>\n<li><code>^</code>:匹配文字的开头。如果正则表达式的匹配模式设置为’,’m’则也匹配每个换行符或者回车符之后的位置。</li>\n<li><code>$</code>:匹配文字的开头。如果正则表达式的匹配模式设置为’,’m’则也匹配每个换行符或者回车符之前的位置。</li>\n<li><code>/b</code>:匹配单词边界，不匹配任何字符。</li>\n</ol>\n<p>所谓的“单词”，就是位于\\w（ASCII单词）和\\W（非ASCII单词）之间的边界，或者位于ASCII单词与字符串开始或者结尾的合法位置。所以\\/bjava/b\\不匹配“javascript is more than java”中的javascript中java而只匹配之后的单词“java”。</p>\n<p>而因为javascript只支持ASCII字符不支持Unicode的，所以在javascript这门语言中\\w就可以等价于[a-zA-Z0-9]，也因为于此，javascript中\\w是不包括中文已经其他Unicode码特殊符号的，如下例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"html5_css3中文_h5$c3&amp;汉字%\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str.match(<span class=\"regexp\">/\\w+/g</span>)); <span class=\"comment\">//\"html5_css3\" , \"_h5\" , \"c3\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str.match(<span class=\"regexp\">/.\\b./g</span>));<span class=\"comment\">//\"3中\" , \"文_\" , \"5$\" , \"3&amp;\"</span></span><br></pre></td></tr></table></figure>\n<p>第一个例子中\\w+匹配了”html5_css3” , “<em>h5” , “c3”三个字符串，而其他的因为javascript只能匹配ASCII码的字符，所以除了字母、数字、“</em>“以及”$“的字符就都成单词的边界；而当使用.\\b.（除了换行符之外的任意字符，.匹配了那些\\w无法识别的Unicode码字符）匹配时，我们又得到”3中” , “文<em>“ , “5&amp;” ,说明这个字符串中有4个分界点5个子字符串，分别在”3中” , “文</em>“ , “5&amp;”之间，而四个子字符串分别是”html5_css3”，”中文,”_h5”,”$c3”,”&amp;汉字%”。</p>\n<p>所以，在处理一些字符串时，如果要使用\\b得先确认是否还有ASCII码的字符。</p>\n<p>注意：\\b在[]中表示退格。</p>\n<h3 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h3><p>学习完以上的，应该会知道中括号用来限定字符类的范围，大括号则用来指定重复的次数，而小括号除了限制多选项的范围以及将若干字符组合为一个单位让量词能影响这个单元。还有一个用途就是，小括号能”记住“它们匹配成功的文本，在正则表达式的后面引用前面“记住”的匹配文本，通过 \\后加以为或者多位数字来实现，也就是“反向引用”。</p>\n<p>看实际例子吧：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1分组+量词</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"regexp\">/(js)&#123;2&#125;/</span>.test(<span class=\"string\">\"jsjs\"</span>));<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"comment\">//2分组+范围</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"regexp\">/[JL]script/</span>.test(<span class=\"string\">\"Lscript\"</span>));<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"comment\">//3反向引用</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"regexp\">/([jJ])s\\1/</span>.test(<span class=\"string\">\"jsJs\"</span>));<span class=\"comment\">//false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"regexp\">/([jJ])s\\1/</span>.test(<span class=\"string\">\"jsjs\"</span>));<span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>例1和例2将括号内的若干字符组合为一个单位。而例3因为\\1引用的是之前匹配成功的字符串，所以例三中\\1就只能匹配”js“而不能匹配”Js“。</p>\n<p>然后介绍第二个分组的符号|。</p>\n<p>与小括号不同，小括号内的是一个整体（独立的子表达式），而|分割开的各分支是多选分支，即你可以选择|前面的也可以选择|后面的，如果有多个|隔开则是多选几。如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"regexp\">/(html5|css3|js)!!/</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(reg.test(<span class=\"string\">\"html5!!\"</span>));<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(reg.test(<span class=\"string\">\"css3!!\"</span>));<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(reg.test(<span class=\"string\">\"js!!\"</span>));<span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"非捕获性分组\"><a href=\"#非捕获性分组\" class=\"headerlink\" title=\"非捕获性分组\"></a>非捕获性分组</h3><p>对带圆括号的子表达式的引用确实强大，但是既然能够反向引用，正则引擎肯定是保存了括号内的一些信息。所以从效率角度来看，如果只是为了分组而不反向引用的话就采取非捕获性分组的方法。要创建一个非捕获性分组，只要在捕获性分组的左括号的后面紧跟一个问号与冒号就行了。</p>\n<p>从字面意思来看：非捕获分组能分组，但是不能捕获各个组的信息。如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> pattern1 = <span class=\"string\">\"JS,HTML5,CSS\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(pattern1.replace(<span class=\"regexp\">/(\\w+),(?:\\w+)/</span>, <span class=\"string\">\"$2,$1\"</span>));<span class=\"comment\">//$2,JS,CSS</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"前瞻\"><a href=\"#前瞻\" class=\"headerlink\" title=\"前瞻\"></a>前瞻</h3><p>前瞻也是属于零宽断言，说白了就是匹配位置的高级变体。前面我们说过的只是单纯的开头、结尾以及单词的边界，而前瞻的匹配则更加随意，如下：</p>\n<ol>\n<li><code>(?=p)</code>:要求之后的字符必须与p匹配</li>\n<li><code>(?!p)</code>:要求之后的字符必须不与p匹配</li>\n</ol>\n<p>如下实例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> reg1 = <span class=\"regexp\">/java(?!Scrit)/</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> reg2 = <span class=\"regexp\">/java(?=Scrit)/</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(reg1.test(<span class=\"string\">\"javaScrit\"</span>)); <span class=\"comment\">//false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(reg1.test(<span class=\"string\">\"javaB\"</span>));<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(reg2.test(<span class=\"string\">\"javaScrit\"</span>)); <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(reg2.test(<span class=\"string\">\"javaB\"</span>));<span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure></p>\n<p>前瞻的作用就是给正则增加一个附加条件，只有满足条件，才能继续走下去，前瞻匹配的结果是不纳入结果里的，只是一个条件。</p>\n<p>支持正则方法有支持正则的字符串方法和正则自身的方法</p>\n<h2 id=\"支持正则表达式的-String-对象的方法\"><a href=\"#支持正则表达式的-String-对象的方法\" class=\"headerlink\" title=\"支持正则表达式的 String 对象的方法\"></a>支持正则表达式的 String 对象的方法</h2><h3 id=\"字符串搜索：\"><a href=\"#字符串搜索：\" class=\"headerlink\" title=\"字符串搜索：\"></a>字符串搜索：</h3><p><code>search()</code>方法用于检索字符串中指定的子字符串，返回匹配的字符的位置（0-~）。</p>\n<p>如果没有找到匹配的字符，则返回-1；将忽略RegExp中的全局模式，只返回第一个匹配的位置。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> pattern = <span class=\"string\">\"hello html5 js css\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(pattern.search(<span class=\"regexp\">/Html5/i</span>));<span class=\"comment\">//6</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"字符串匹配：\"><a href=\"#字符串匹配：\" class=\"headerlink\" title=\"字符串匹配：\"></a>字符串匹配：</h3><p><code>match()</code>方法可以返回匹配结果的数组，并且依赖于regexp的全局标志g。如果没有全局标志g，则只匹配一次；如果有，则匹配多次直到结束，最后返回一个存有匹配匹配文本的数组。</p>\n<p><code>match()</code>即不提供与子表达式匹配的文本的信息，也不声明每个匹配子串的索引位置。如果您需要这些信息，可以使用 RegExp.exec()。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> pattern=<span class=\"string\">\"2012 years 12 month 20 is the end of the world\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(pattern.match(<span class=\"regexp\">/\\d+/g</span>));<span class=\"comment\">//[\"2012\",\"12\",\"20\"]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"字符串替代：\"><a href=\"#字符串替代：\" class=\"headerlink\" title=\"字符串替代：\"></a>字符串替代：</h3><p><code>replace()</code>方法用于替换字符串或者正则表达式匹配的子字符串，并且也依赖于regexp的全局标志g。如果没有全局标志g，则只替换第一个匹配的子字符串；如果有，则替换所有匹配的子字符串。</p>\n<p><code>replace()</code>的第二个参数可以是字符串，也可以是函数。如果是字符串，则由每个匹配的字符串替换，其中 $ 具有特殊的含义：</p>\n<ol>\n<li><code>$n</code>：其中n表示1-99，表示匹配的子字符串中的第n个，n就是带圆括号的子表达式的位置。</li>\n<li><code>$&amp;</code>：全部匹配的子字符串</li>\n<li>`$``：匹配子串左侧的文本</li>\n<li><code>$&#39;</code>：匹配子串右侧的文本</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> pattern1 = <span class=\"string\">\"JS,HTML5,CSS\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> replace1 = pattern1.replace(<span class=\"regexp\">/(\\w&#123;1,&#125;),(\\w+)/</span>, <span class=\"string\">\"$2,$1\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(replace1);<span class=\"comment\">//HTML5,JS,CSS</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> replace2 = pattern1.replace(<span class=\"regexp\">/(\\w+),/g</span>,<span class=\"string\">\"$1-\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(replace2);<span class=\"comment\">//JS-HTML5-CSS</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"字符串分割：\"><a href=\"#字符串分割：\" class=\"headerlink\" title=\"字符串分割：\"></a>字符串分割：</h3><p><code>split()</code>方法用于把一个字符串分割成字符串数组。该方法有两个参数，第一个参数是指定分割的边界；第二个参数是指定返回数组的长度，如果没有则字符串之间的都会被分割。</p>\n<p>若使用 <code>split(&quot;&quot;)</code> 则会将单词分割成字母<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> pattern = <span class=\"string\">\"HTML5 JS CSS\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> sWord1 = pattern.split(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> sWord2 = pattern.split(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sWord1);<span class=\"comment\">//[ \"HTML5\" , \"JS\" , \"CSS\" ]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sWord2);<span class=\"comment\">//[ \"H\" , \"T\" , \"M\" , \"L\" , \"5\" , \" \" , \"J\" , \"S\" , \" \" , \"C\" , \"S\" , \"S\"]</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"RegExp-对象的方法\"><a href=\"#RegExp-对象的方法\" class=\"headerlink\" title=\"RegExp 对象的方法\"></a>RegExp 对象的方法</h2><h2 id=\"test：\"><a href=\"#test：\" class=\"headerlink\" title=\"test：\"></a>test：</h2><p>test()方法用于检索要检测的字符串是否存在，若含有与regExp相匹配的文本，则返回true，否则返回false</p>\n<h2 id=\"exec：\"><a href=\"#exec：\" class=\"headerlink\" title=\"exec：\"></a>exec：</h2><p>exec()方法用于匹配字串，跟不是全局的match()方法很类似，但是它不仅能检索字符串中指定的值，返回找到的值，还能确定其位置。 比match()强大。如果利用 exec() 的lastIndex属性反复调用同样可以模拟match()全局检索字符串的效果。</p>\n","excerpt":"<p>正则表达式是一个威力巨大的处理字符串的工具，能够高效、神奇得完成对字符串的操作。相比较简单的字符串比较、查找、替换，正则表达式提供了更加强大的处理能力。正则表达式的价值就在于，不用正则来解决问题会让人疯掉，但是用了之后“纠结”的问题已不再是问题了。而且因为正则表达式用的不是一个固化的、具体的字符串来匹配字符串，而是抽象的模式的，所以只要正则写的规则没问题，一般都都能高效的完成任务。</p>\n<p>虽然正则表达式看起来确实很像外星文，就像变魔术一样，魔术本身也不神奇，只是的观众不解其中奥妙。学会了其中的规则，我们再去使用，肯定会发出感慨：神奇、复杂、好用。<br>","more":"<br>正则到底强在哪里呢？我们举个简单的例子：在一串包含数字以及英文字母的字符串中中找出数字并保存在数组中。代码如下：</p>\n<p><strong>不使用正则：</strong><br>遍历字符串，利用字符串charAt()的方法将字符串中的数字检索出来，再push数组中，然后继续检索再push到数组中直到结束。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">var</span> str = <span class=\"string\">'12 javascript 34 html5 33 php 77 css'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> arr = [];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> figure = <span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i=<span class=\"string\">'0'</span> &amp;&amp; str.charAt(i)&lt;=<span class=\"string\">'9'</span>)&#123;</span><br><span class=\"line\">            figure += str.charAt(i);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(figure)&#123;</span><br><span class=\"line\">            arr.push(tmp);</span><br><span class=\"line\">            figure =<span class=\"string\">''</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr)<span class=\"comment\">//[ \"12\" , \"34\" , \"5\" , \"33\" , \"77\" ]</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>而使用正则只需要如下短短的一行代码</strong>：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = str.match(<span class=\"regexp\">/\\d+/g</span>);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><h3 id=\"书写风格\"><a href=\"#书写风格\" class=\"headerlink\" title=\"书写风格\"></a>书写风格</h3><p>javascript中的正则是Perl5的正则表达式语法的大子集，所以在javascript中创建正则有js风格和petl风格两种。</p>\n<ol>\n<li>JS 风格： new RegExp(‘patten’,’ig’)</li>\n<li>perl风格：/patten/ig</li>\n</ol>\n<p>JS风格其实就是通过RegExp对象来表示，而perl风格更普遍的叫法是RegExp直接量。这两个语法都是一样的，只是转义字符的写法不同。</p>\n<h3 id=\"什么是正则\"><a href=\"#什么是正则\" class=\"headerlink\" title=\"什么是正则\"></a>什么是正则</h3><p>正则表达式的结构与数学表达式很类似。</p>\n<p>一个数学表达式由若干个“项”组成，“项”与“项”之间用加号或减号相连</p>\n<p>为了方便理解，让我们先来看看大家一个典型的的数学表达式 <code>(x+3)*2+y</code>：</p>\n<p>这个数学表达式中<code>(x+3)*2</code>和<code>y</code>分别是两个项。每个项又由若干个<strong>因子</strong>组成，因子之间用乘号或除号相连。这里第一个项有两个因子<code>(x+3)</code>和<code>2</code>，而第二个项只有一个因子“y”。每个因子可以是一个简单的数，一个代数变量，也可以是放在括号里面的一个表达式，括号中的表达式称为<strong>子表达式</strong>。这里<code>x+3</code>就是一个子表达式。</p>\n<p>与数学表达式的<strong>因子</strong>相对应，构成正则表达式的部件称为<strong>单位</strong>；<strong>项</strong>则与正则表达式的子表达式相对应。而从逻辑上讲，子表达式之间是串接的关系，一个字符串必须与每个子表达式依次相匹配，才算与这个表达式相匹配。</p>\n<h3 id=\"术语\"><a href=\"#术语\" class=\"headerlink\" title=\"术语\"></a>术语</h3><p>为了更好的学习正则，我们再来学习下正则表达式的一些术语</p>\n<ol>\n<li><p>匹配（matching）<br>一个正则表达式“匹配”一个字符串，其实是指这个正则表达式能在字符串中找到匹配文本。</p>\n</li>\n<li><p>元字符（metacharacter）<br>只有在字符组外部并且是在未转义之前的情况下，才是一个元字符。</p>\n</li>\n<li><p>子表达式（subexpression）<br> 子表达式指的一般是整个正则表达式中的一部分，通常是括号内的表达式，或者有|分隔的多选分支。子表达式由不可分割的单位组成。与多选分支不同的是，量词作用的对象是他们之前紧邻的子表达式。而如果量词之前紧邻的是一个括号保卫的自表达式，则不管其多么复杂都被视为一个单元。</p>\n</li>\n</ol>\n<h3 id=\"匹配模式\"><a href=\"#匹配模式\" class=\"headerlink\" title=\"匹配模式\"></a>匹配模式</h3><p>上例中斜杠后面的 <code>ig</code>是匹配模式，可选的值有3个：<code>i</code>,<code>g</code>,<code>m</code>。其含义如下：</p>\n<ul>\n<li><code>i</code>：为 ignore case，即 忽略大小写。</li>\n<li><code>g</code>：为 global search，即全局搜索。</li>\n<li><code>m</code>：为 moltiline search，即多行搜索。</li>\n</ul>\n<p>所以，一个完整正则表达式是由一个个<strong>子表达式</strong>组成的，而<strong>子表达式</strong>则是由各种符号组成，这些符号按照功能可以分成以下类：转义字符、预定义特殊字符、字符类、量词、贪婪模式和非贪婪模式、匹配位置、分组、非捕获性分组、前瞻（零宽断言）。</p>\n<h2 id=\"元字符组成部分\"><a href=\"#元字符组成部分\" class=\"headerlink\" title=\"元字符组成部分\"></a>元字符组成部分</h2><h3 id=\"转义字符\"><a href=\"#转义字符\" class=\"headerlink\" title=\"转义字符\"></a>转义字符</h3><p>什么是转义字符？在\\后面加字符就可以转义为特殊字符。</p>\n<p>例如： <code>\\n</code>匹配一个换行符， <code>\\\\</code>匹配“\\”。</p>\n<h3 id=\"预定义特殊字符\"><a href=\"#预定义特殊字符\" class=\"headerlink\" title=\"预定义特殊字符\"></a>预定义特殊字符</h3><ol>\n<li><code>\\o</code>:Nol字符。</li>\n<li><code>\\t</code>:水平制表符。</li>\n<li><code>\\v</code>:垂直制表符。</li>\n<li><code>\\n</code>:换行符。</li>\n<li><code>\\r</code>:回车符。</li>\n<li><code>\\b</code>:退格符。 只有出现在字符中才有效，即[]（中括号）中。</li>\n</ol>\n<h3 id=\"字符类\"><a href=\"#字符类\" class=\"headerlink\" title=\"字符类\"></a>字符类</h3><ol>\n<li><code>[ ]</code>:表示范围，一个字符的集合，匹配该集合中的任意一个字符，例如 <code>[abc]</code>就可以匹配”css”中的c；<br>如果上例前面加 ^元字符，形如<code>[^asd]</code>，则表示匹配除了asd的其他字符；</li>\n</ol>\n<p>如果觉得匹配的字符太多，而且类型相似，则可以用-元字符表示，那么上例就可以这么写<code>[a-c]</code>这么写，所以上例也可以这么写 <code>[^a-d]</code></p>\n<ol>\n<li><code>\\w</code>和<code>\\W</code>:<code>\\w</code>表示匹配任何ASCII字符组成的单词，等价于[a-zA-Z0-9]；<code>\\W</code>表示匹配不是ASCII字符组成的单词等价于<code>[^a-zA-Z0-9]</code>。</li>\n<li><code>\\s</code>和<code>\\S</code>:<code>\\s</code>匹配空白符，等价于<code>[\\t\\n\\x0B\\f\\r]</code>；<code>\\S</code>则匹配非空白字符，等价于<code>[^\\t\\n\\x0B\\f\\r]</code>。</li>\n<li><code>\\d</code>和<code>\\D</code>:<code>\\d</code>匹配数字字符，等价于<code>[0-9]</code>；<code>\\D</code>匹配数字字符，等价于<code>[^0-9]</code></li>\n<li><p><code>.</code>:javascript有点特殊，由于浏览器的解析引擎不同，<code>.</code>的匹配范围也有所不同。</p>\n<ol>\n<li><p>IE8以下：<br>.匹配所有除了换行符<code>/n</code>换行符之外的任意字符。等同于<code>[^\\n\\r]</code></p>\n</li>\n<li><p>IE9以上以及其他浏览器<br>.匹配所有除了换行符<code>/n</code>换行符和回车符<code>\\r</code>之外的任意字符。等同于<code>[^\\n\\r]</code></p>\n</li>\n</ol>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"regexp\">/./</span>.test(<span class=\"string\">\"\\r\"</span>) + <span class=\"string\">\"\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"regexp\">/./</span>.test(<span class=\"string\">\"\\n\"</span>) + <span class=\"string\">\"\"</span>);</span><br><span class=\"line\"><span class=\"comment\">/*IE8以下输出true false；IE9以上及其他浏览器输出 false false*/</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"量词\"><a href=\"#量词\" class=\"headerlink\" title=\"量词\"></a>量词</h3><p>首先我们得了解匹配量词都是匹配优先的，简单说就是匹配量词的结果总是尝试匹配尽可能多的字符，直到匹配上限为止，然后为了让整个表达式匹配成功，就需要“释放”之前优先匹配的字符，所以也被称为贪婪模式。</p>\n<p>而既然有贪婪模式，则一定也有非贪婪模式。</p>\n<p>对于贪婪模式和非贪婪模式影响的是被量词修饰的子表达式的匹配行为，既在贪婪模式下，在整个表达式匹配成功的前提下，尽可能多的匹配，而非贪婪模式在在整个表达式匹配成功的前提下，尽可能少的匹配。而且允许允许接下来的正则继续匹配。</p>\n<p>贪婪模式的量词，也叫简单量词，如下：</p>\n<p><code>{n}</code>:n是一个正整数，表示前一个子表达式匹配n次。例如： /o{2}/匹配两次o，它可以匹配”footer“，但是不能匹配hot中的o。<br><code>{n,}</code>:n是一个正整数，表示前一个子表达式至少匹配n次。例如：/o{2,}/，它可以匹配“footer”，也可以匹配“fooooooooooter”。<br><code>{n,m}</code>:n、m都是正整数，表示至少匹配n次，至多m次。<br><code>?</code>:等价于{0,1}<br><code>+</code>:等价于{1,}<br><code>*</code>:等价于{0,}<br>而在贪婪模式后加上 ?就变成了非贪婪模式。</p>\n<h3 id=\"贪婪模式和非贪婪模式\"><a href=\"#贪婪模式和非贪婪模式\" class=\"headerlink\" title=\"贪婪模式和非贪婪模式\"></a>贪婪模式和非贪婪模式</h3><p>在上面提到的一个前提条件就是在整个表达式匹配成功，为什么要强调这个前提条件呢，看如下例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> pattern = <span class=\"string\">'aAaAaAb'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"regexp\">/a+/i</span>.exec(pattern)); <span class=\"comment\">//aAaAaA</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"regexp\">/a+?/i</span>.exec(pattern)); <span class=\"comment\">//a</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"regexp\">/a+b/i</span>.exec(pattern)); <span class=\"comment\">//aAaAaAb</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"regexp\">/a+?b/i</span>.exec(pattern)); <span class=\"comment\">//aAaAaAb</span></span><br></pre></td></tr></table></figure>\n<p>全部是在忽略大小写的模式下：</p>\n<ol>\n<li>第一个匹配结果解释：采用贪婪模式，在匹配第一个“a”时，整个表达式匹配成功了，由于采用了贪婪模式，所以仍然向右匹配，向右再也没有可以成功匹配的子字串，匹配结束，最终匹配结果为“aAaAaA”</li>\n<li>第二个匹配结果解释：采用非贪婪模式，在匹配第一个“a”时，整个表达式匹配成功了，由于采用了非贪婪模式，所以结束匹配，最终匹配结果为“a。”</li>\n<li>第三个匹配结果解释：采用贪婪模式，所以a+仍然可以匹配到“aAaAaA”，但是由于后面的 b无法匹配成功，所以为了让整个表达式匹配成功，a+必须让出前面的匹配内容，所以最终匹配结果为“aAaAaAb”。</li>\n<li>第四个匹配结果解释：采用非贪婪模式，所以a+任然可以匹配到“a”，但是由于后面的 b无法匹配成功，所以为了让整个表达式匹配成功，a+必须继续匹配后面的直到“b”，所以最终匹配结果跟采用贪婪模式的匹配结果一样，也为“aAaAaAb”。</li>\n<li>所以，不管是贪婪模式还是非贪婪模式，都只有在整个表达式匹配成功的前提下量词才能影响字表达式的匹配行为。贪婪跟非贪婪模式主要功能是提高匹配效率，贪婪模式下可能会越过后面的正则，从而会导致匹配的回溯问题。所以在前面的正则坑会会越过后面的正则的情况下，请使用非贪婪模式。</li>\n</ol>\n<h3 id=\"匹配位置\"><a href=\"#匹配位置\" class=\"headerlink\" title=\"匹配位置\"></a>匹配位置</h3><p>前面说的量词是修饰子字符串的重复次数，而匹配位置则是来表示子字符串的出现位置，匹配的只是一个位置，所以是零宽度的。</p>\n<ol>\n<li><code>^</code>:匹配文字的开头。如果正则表达式的匹配模式设置为’,’m’则也匹配每个换行符或者回车符之后的位置。</li>\n<li><code>$</code>:匹配文字的开头。如果正则表达式的匹配模式设置为’,’m’则也匹配每个换行符或者回车符之前的位置。</li>\n<li><code>/b</code>:匹配单词边界，不匹配任何字符。</li>\n</ol>\n<p>所谓的“单词”，就是位于\\w（ASCII单词）和\\W（非ASCII单词）之间的边界，或者位于ASCII单词与字符串开始或者结尾的合法位置。所以\\/bjava/b\\不匹配“javascript is more than java”中的javascript中java而只匹配之后的单词“java”。</p>\n<p>而因为javascript只支持ASCII字符不支持Unicode的，所以在javascript这门语言中\\w就可以等价于[a-zA-Z0-9]，也因为于此，javascript中\\w是不包括中文已经其他Unicode码特殊符号的，如下例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"html5_css3中文_h5$c3&amp;汉字%\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str.match(<span class=\"regexp\">/\\w+/g</span>)); <span class=\"comment\">//\"html5_css3\" , \"_h5\" , \"c3\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str.match(<span class=\"regexp\">/.\\b./g</span>));<span class=\"comment\">//\"3中\" , \"文_\" , \"5$\" , \"3&amp;\"</span></span><br></pre></td></tr></table></figure>\n<p>第一个例子中\\w+匹配了”html5_css3” , “<em>h5” , “c3”三个字符串，而其他的因为javascript只能匹配ASCII码的字符，所以除了字母、数字、“</em>“以及”$“的字符就都成单词的边界；而当使用.\\b.（除了换行符之外的任意字符，.匹配了那些\\w无法识别的Unicode码字符）匹配时，我们又得到”3中” , “文<em>“ , “5&amp;” ,说明这个字符串中有4个分界点5个子字符串，分别在”3中” , “文</em>“ , “5&amp;”之间，而四个子字符串分别是”html5_css3”，”中文,”_h5”,”$c3”,”&amp;汉字%”。</p>\n<p>所以，在处理一些字符串时，如果要使用\\b得先确认是否还有ASCII码的字符。</p>\n<p>注意：\\b在[]中表示退格。</p>\n<h3 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h3><p>学习完以上的，应该会知道中括号用来限定字符类的范围，大括号则用来指定重复的次数，而小括号除了限制多选项的范围以及将若干字符组合为一个单位让量词能影响这个单元。还有一个用途就是，小括号能”记住“它们匹配成功的文本，在正则表达式的后面引用前面“记住”的匹配文本，通过 \\后加以为或者多位数字来实现，也就是“反向引用”。</p>\n<p>看实际例子吧：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1分组+量词</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"regexp\">/(js)&#123;2&#125;/</span>.test(<span class=\"string\">\"jsjs\"</span>));<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"comment\">//2分组+范围</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"regexp\">/[JL]script/</span>.test(<span class=\"string\">\"Lscript\"</span>));<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"comment\">//3反向引用</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"regexp\">/([jJ])s\\1/</span>.test(<span class=\"string\">\"jsJs\"</span>));<span class=\"comment\">//false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"regexp\">/([jJ])s\\1/</span>.test(<span class=\"string\">\"jsjs\"</span>));<span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>例1和例2将括号内的若干字符组合为一个单位。而例3因为\\1引用的是之前匹配成功的字符串，所以例三中\\1就只能匹配”js“而不能匹配”Js“。</p>\n<p>然后介绍第二个分组的符号|。</p>\n<p>与小括号不同，小括号内的是一个整体（独立的子表达式），而|分割开的各分支是多选分支，即你可以选择|前面的也可以选择|后面的，如果有多个|隔开则是多选几。如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"regexp\">/(html5|css3|js)!!/</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(reg.test(<span class=\"string\">\"html5!!\"</span>));<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(reg.test(<span class=\"string\">\"css3!!\"</span>));<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(reg.test(<span class=\"string\">\"js!!\"</span>));<span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"非捕获性分组\"><a href=\"#非捕获性分组\" class=\"headerlink\" title=\"非捕获性分组\"></a>非捕获性分组</h3><p>对带圆括号的子表达式的引用确实强大，但是既然能够反向引用，正则引擎肯定是保存了括号内的一些信息。所以从效率角度来看，如果只是为了分组而不反向引用的话就采取非捕获性分组的方法。要创建一个非捕获性分组，只要在捕获性分组的左括号的后面紧跟一个问号与冒号就行了。</p>\n<p>从字面意思来看：非捕获分组能分组，但是不能捕获各个组的信息。如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> pattern1 = <span class=\"string\">\"JS,HTML5,CSS\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(pattern1.replace(<span class=\"regexp\">/(\\w+),(?:\\w+)/</span>, <span class=\"string\">\"$2,$1\"</span>));<span class=\"comment\">//$2,JS,CSS</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"前瞻\"><a href=\"#前瞻\" class=\"headerlink\" title=\"前瞻\"></a>前瞻</h3><p>前瞻也是属于零宽断言，说白了就是匹配位置的高级变体。前面我们说过的只是单纯的开头、结尾以及单词的边界，而前瞻的匹配则更加随意，如下：</p>\n<ol>\n<li><code>(?=p)</code>:要求之后的字符必须与p匹配</li>\n<li><code>(?!p)</code>:要求之后的字符必须不与p匹配</li>\n</ol>\n<p>如下实例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> reg1 = <span class=\"regexp\">/java(?!Scrit)/</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> reg2 = <span class=\"regexp\">/java(?=Scrit)/</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(reg1.test(<span class=\"string\">\"javaScrit\"</span>)); <span class=\"comment\">//false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(reg1.test(<span class=\"string\">\"javaB\"</span>));<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(reg2.test(<span class=\"string\">\"javaScrit\"</span>)); <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(reg2.test(<span class=\"string\">\"javaB\"</span>));<span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure></p>\n<p>前瞻的作用就是给正则增加一个附加条件，只有满足条件，才能继续走下去，前瞻匹配的结果是不纳入结果里的，只是一个条件。</p>\n<p>支持正则方法有支持正则的字符串方法和正则自身的方法</p>\n<h2 id=\"支持正则表达式的-String-对象的方法\"><a href=\"#支持正则表达式的-String-对象的方法\" class=\"headerlink\" title=\"支持正则表达式的 String 对象的方法\"></a>支持正则表达式的 String 对象的方法</h2><h3 id=\"字符串搜索：\"><a href=\"#字符串搜索：\" class=\"headerlink\" title=\"字符串搜索：\"></a>字符串搜索：</h3><p><code>search()</code>方法用于检索字符串中指定的子字符串，返回匹配的字符的位置（0-~）。</p>\n<p>如果没有找到匹配的字符，则返回-1；将忽略RegExp中的全局模式，只返回第一个匹配的位置。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> pattern = <span class=\"string\">\"hello html5 js css\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(pattern.search(<span class=\"regexp\">/Html5/i</span>));<span class=\"comment\">//6</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"字符串匹配：\"><a href=\"#字符串匹配：\" class=\"headerlink\" title=\"字符串匹配：\"></a>字符串匹配：</h3><p><code>match()</code>方法可以返回匹配结果的数组，并且依赖于regexp的全局标志g。如果没有全局标志g，则只匹配一次；如果有，则匹配多次直到结束，最后返回一个存有匹配匹配文本的数组。</p>\n<p><code>match()</code>即不提供与子表达式匹配的文本的信息，也不声明每个匹配子串的索引位置。如果您需要这些信息，可以使用 RegExp.exec()。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> pattern=<span class=\"string\">\"2012 years 12 month 20 is the end of the world\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(pattern.match(<span class=\"regexp\">/\\d+/g</span>));<span class=\"comment\">//[\"2012\",\"12\",\"20\"]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"字符串替代：\"><a href=\"#字符串替代：\" class=\"headerlink\" title=\"字符串替代：\"></a>字符串替代：</h3><p><code>replace()</code>方法用于替换字符串或者正则表达式匹配的子字符串，并且也依赖于regexp的全局标志g。如果没有全局标志g，则只替换第一个匹配的子字符串；如果有，则替换所有匹配的子字符串。</p>\n<p><code>replace()</code>的第二个参数可以是字符串，也可以是函数。如果是字符串，则由每个匹配的字符串替换，其中 $ 具有特殊的含义：</p>\n<ol>\n<li><code>$n</code>：其中n表示1-99，表示匹配的子字符串中的第n个，n就是带圆括号的子表达式的位置。</li>\n<li><code>$&amp;</code>：全部匹配的子字符串</li>\n<li>`$``：匹配子串左侧的文本</li>\n<li><code>$&#39;</code>：匹配子串右侧的文本</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> pattern1 = <span class=\"string\">\"JS,HTML5,CSS\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> replace1 = pattern1.replace(<span class=\"regexp\">/(\\w&#123;1,&#125;),(\\w+)/</span>, <span class=\"string\">\"$2,$1\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(replace1);<span class=\"comment\">//HTML5,JS,CSS</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> replace2 = pattern1.replace(<span class=\"regexp\">/(\\w+),/g</span>,<span class=\"string\">\"$1-\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(replace2);<span class=\"comment\">//JS-HTML5-CSS</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"字符串分割：\"><a href=\"#字符串分割：\" class=\"headerlink\" title=\"字符串分割：\"></a>字符串分割：</h3><p><code>split()</code>方法用于把一个字符串分割成字符串数组。该方法有两个参数，第一个参数是指定分割的边界；第二个参数是指定返回数组的长度，如果没有则字符串之间的都会被分割。</p>\n<p>若使用 <code>split(&quot;&quot;)</code> 则会将单词分割成字母<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> pattern = <span class=\"string\">\"HTML5 JS CSS\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> sWord1 = pattern.split(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> sWord2 = pattern.split(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sWord1);<span class=\"comment\">//[ \"HTML5\" , \"JS\" , \"CSS\" ]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sWord2);<span class=\"comment\">//[ \"H\" , \"T\" , \"M\" , \"L\" , \"5\" , \" \" , \"J\" , \"S\" , \" \" , \"C\" , \"S\" , \"S\"]</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"RegExp-对象的方法\"><a href=\"#RegExp-对象的方法\" class=\"headerlink\" title=\"RegExp 对象的方法\"></a>RegExp 对象的方法</h2><h2 id=\"test：\"><a href=\"#test：\" class=\"headerlink\" title=\"test：\"></a>test：</h2><p>test()方法用于检索要检测的字符串是否存在，若含有与regExp相匹配的文本，则返回true，否则返回false</p>\n<h2 id=\"exec：\"><a href=\"#exec：\" class=\"headerlink\" title=\"exec：\"></a>exec：</h2><p>exec()方法用于匹配字串，跟不是全局的match()方法很类似，但是它不仅能检索字符串中指定的值，返回找到的值，还能确定其位置。 比match()强大。如果利用 exec() 的lastIndex属性反复调用同样可以模拟match()全局检索字符串的效果。</p>"},{"title":"正则基础深入应用","date":"2017-07-24T06:54:16.000Z","_content":"\n\n本文是一篇真这个表达式的高级教程，主要通过一些例子，深入探讨正则表达式的高级功能。\n\n写好正则首先第一点得对正则的支持都烂熟于心，第二点就是找到我们要取的数据的唯一特点。接下来我们通过几个例子来加强训练。\n\n<!--more-->\n## 密码强度\n\n### 密码必须包含大小写字母和字母和数字，排除特殊自字符，长度在6-12之间\n\n用到了前瞻，如果还不清楚可以移步 [正则基础学习](../javascript-reg-1)\n\n正则一\n````javascript\n(?!^[a-z]+$)(?!^[0-9]+$)(?!^[A-Z]+$)^[a-zA-Z0-9]{6,12}$\n\n````\n\n其中 `(?!)` 这种写法是对后面数据的一种限定，过滤匹配的数据。如 `(?!2)[0-9]` 就是匹配除了2之外的所有数字。\n\n然后，上面那段正则就可以分以下四段分析，因为`(?!)`只是限定条件，不匹配结果，所以前面三个`(?!)`只是三个条件，后面的才是匹配结果：\n* `(?!^[a-z]+$)`: 排除纯小写\n* `(?!^[A-Z]+$)`: 排除纯大写\n* `(?!^[0-9]+$)`: 排除纯数字\n* `^[a-zA-Z0-9]{6,16}$`: 匹配6到12个 [a-zA-Z0-9] 范围中字符\n\n正则二\n````javascript\n^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])[a-zA-Z0-9]{6,12}$\n````\n\n这段正则是上面的相反逻辑，所以结构有所不一样。上面那段正则是排除，这段正则是限定条件，所以`^` 跟 `$` 位置不同。\n这段正则分以下也三段分析：\n\n* `^(?=.*\\d)[a-zA-Z0-9]{6,12}$`: 匹配大小写字母以及数字，匹配的字符中必须有数字。\n* `^(?=.*[a-z])[a-zA-Z0-9]{6,12}$`: 匹配大小写字母以及数字，匹配的字符中必须有小写字母。\n* `^(?=.*[A-Z])[a-zA-Z0-9]{6,12}$`:  匹配大小写字母以及数字，匹配的字符中必须有大写字母。\n\n\n## 整数部分千分位\n现实中，土豪的存折里存的钱会是天文数字，没有千分位隔开，不好数自己的钱，\n互利网中也是如此。\n我们需要将数字整数部分加千分位，小数部分加千分位没必要，一般只精确到后两位。\n因为js没有后瞻，所以首先大家可以将小数点前面的整数提取出来。\n\n方法如下：\n````javascript\n99999999999'.replace(/\\d{1,3}(?=(\\d{3})+)/g, '$&,');\n````\n\n* `(\\d{3})+`表示一组及以上3的倍数个数字加小数点\n* 然后用正向肯定查找 `(?=)` 包起来，说明 `(\\d{3})+` 只是一个条件\n* `g` 表示匹配多次直到没匹配到结果\n* `$&` 表示 `\\d{1,3}` 正向查找条件成立时匹配到的结果\n\n所以，这个正则匹配过程可以理解成：如果匹配到数字1~3个，如果后面的数字刚好是3的倍数，那就符合规则，`$&`提取再加上千分位符，接着继续匹配，知道读到百位后，已经不能满足`\\d{1,3}` 后才停止匹配。\n\n* [怎么引用replace匹配到的结果](../javascript-reg-1#字符串替代：) 知识点。\n\n## 匹配身份证号码\n\n正则匹配身份证号，根据身份证号码的规律，我们得出以下正则：\n\n````javascript\n(?:1[1-5]|2[1-3]|3[1-7]|4[1-6]|5[0-4]|6[1-5]|71|8[12])(?:(0[1-9])|[1-6][1-9]|70)(?:(0[1-9])|1[0-8]|[2-9][1-9])(?:(?:(19[0-9]{2}|200[0-9]|201[0-7])(?:(?:(?:0[1-9]|1[0-2])(?:0[1-9]|1[0-9]|2[0-8]))|(?:(?:0[13-9]|1[0-2])(?:29|30))|(?:0[13578]|1[02])31))|(?:(?:(19|20)(?:0[48]|[2468][048]|[13579][26]))|2000)0229)(?:[0-9]{3}[0-9X]);\n````\n\n\n### 正则分析\n#### 前六位地址码\n\n百度百科上对于前六位中国大陆居民身份证号码中的地址码的数字编码规则解释：\n{% blockquote %}\n华北地区： 北京市|110000，天津市|120000，河北省|130000，山西省|140000，内蒙古自治区|150000，\n东北地区： 辽宁省|210000，吉林省|220000，黑龙江省|230000，\n华东地区： 上海市|310000，江苏省|320000，浙江省|330000，安徽省|340000，福建省|350000，江西省|360000，山东省|370000，\n华中地区： 河南省|410000，湖北省|420000，湖南省|430000，\n华南地区： 广东省|440000，广西壮族自治区|450000，海南省|460000，\n西南地区： 四川省|510000，贵州省|520000，云南省|530000，西藏自治区|540000，重庆市|500000，\n西北地区： 陕西省|610000，甘肃省|620000，青海省|630000，宁夏回族自治区|640000，新疆维吾尔自治区|650000，\n特别地区：台湾地区(886)|710000，香港特别行政区（852)|810000，澳门特别行政区（853)|820000\n\n第一、二位表示省（自治区、直辖市、特别行政区）。\n第三、四位表示市（地级市、自治州、盟及国家直辖市所属市辖区和县的汇总码）。其中，01-20，51-70表示省直辖市；21-50表示地区（自治州、盟）。\n第五、六位表示县（市辖区、县级市、旗）。01-18表示市辖区或地区（自治州、盟）辖县级市；21-80表示县（旗）；81-99表示省直辖县级市。\n{% endblockquote %}\n\n根据以上规则得出以下地址码正则：\n* 第一二位省码：`(?:1[1-5]|2[1-3]|3[1-7]|4[1-6]|5[0-4]|6[1-5]|71|8[12])`\n* 第三四位市码：`(?:(0[1-9])|[1-6][1-9]|70)`\n* 第五六位县码：`(?:(0[1-9])|1[0-8]|[2-9][1-9])` \n\n#### 中间八位生日期码\n\n中间八位是生日器码，YYYYMMDD 格式。因为日期不仅有大小月，还有闰年，但是这里只需要19和20开头的闰年，正则长度小了不少。\n首先从每个月都有的1-28号开始\n`(?:0[1-9]|1[0-2])(?:0[1-9]|1[0-9]|2[0-8])`\n\n然后除2月之外都有29号跟30号\n`(?:0[13-9]|1[0-2])(?:29|30)`\n\n接着1、3、5、7、8、10、12月有31号\n`(?:0[13578]|1[02])31`\n\n以上日期码前面再加上年 `(19[0-9]{2}|200[0-9]|201[0-7])`，这样子除了闰年的所有日期就都ok了，最后再来写闰年。\n闰年的规则是能被4整除单不能被100整除，或者能被400整除。这里我们只写19和20开头的的年份。能被4整除不能被100整除的后两位\n`(0[48]|[2468][048]|[13579][26])`\n能被400整除的1900之后也就只有2000符合规则，2400年得过400年。这些年份写好了，再加上0229就ok了。\n最后我我们用`|`连接起来。\n\n 1900到2017年\n`((?:(19[0-9]{2}|200[0-9]|201[0-7])(?:(?:(?:0[1-9]|1[0-2])(?:0[1-9]|1[0-9]|2[0-8]))|(?:(?:0[13-9]|1[0-2])(?:29|30))|(?:0[13578]|1[02])31))|(?:(?:(19|20)(?:0[48]|[2468][048]|[13579][26]))|2000)0229)`\n\n\n#### 最后四位验证码\n有了地区码和日期码，但是一个地方那一天出生的人肯定不止一人，所以就有了后四位。其中倒数第二个数字男的是单数女的双数，最后一位有可能是罗马数字的X：\n````javascript\n([0-9]{3}[0-9X])\n````\n\n","source":"_posts/javascript-reg-2.md","raw":"title: 正则基础深入应用\ndate: 2017-07-24 14:54:16\ntags:\n- JavaScript\n- 正则\ncategories:\n- JavaScript\n---\n\n\n本文是一篇真这个表达式的高级教程，主要通过一些例子，深入探讨正则表达式的高级功能。\n\n写好正则首先第一点得对正则的支持都烂熟于心，第二点就是找到我们要取的数据的唯一特点。接下来我们通过几个例子来加强训练。\n\n<!--more-->\n## 密码强度\n\n### 密码必须包含大小写字母和字母和数字，排除特殊自字符，长度在6-12之间\n\n用到了前瞻，如果还不清楚可以移步 [正则基础学习](../javascript-reg-1)\n\n正则一\n````javascript\n(?!^[a-z]+$)(?!^[0-9]+$)(?!^[A-Z]+$)^[a-zA-Z0-9]{6,12}$\n\n````\n\n其中 `(?!)` 这种写法是对后面数据的一种限定，过滤匹配的数据。如 `(?!2)[0-9]` 就是匹配除了2之外的所有数字。\n\n然后，上面那段正则就可以分以下四段分析，因为`(?!)`只是限定条件，不匹配结果，所以前面三个`(?!)`只是三个条件，后面的才是匹配结果：\n* `(?!^[a-z]+$)`: 排除纯小写\n* `(?!^[A-Z]+$)`: 排除纯大写\n* `(?!^[0-9]+$)`: 排除纯数字\n* `^[a-zA-Z0-9]{6,16}$`: 匹配6到12个 [a-zA-Z0-9] 范围中字符\n\n正则二\n````javascript\n^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])[a-zA-Z0-9]{6,12}$\n````\n\n这段正则是上面的相反逻辑，所以结构有所不一样。上面那段正则是排除，这段正则是限定条件，所以`^` 跟 `$` 位置不同。\n这段正则分以下也三段分析：\n\n* `^(?=.*\\d)[a-zA-Z0-9]{6,12}$`: 匹配大小写字母以及数字，匹配的字符中必须有数字。\n* `^(?=.*[a-z])[a-zA-Z0-9]{6,12}$`: 匹配大小写字母以及数字，匹配的字符中必须有小写字母。\n* `^(?=.*[A-Z])[a-zA-Z0-9]{6,12}$`:  匹配大小写字母以及数字，匹配的字符中必须有大写字母。\n\n\n## 整数部分千分位\n现实中，土豪的存折里存的钱会是天文数字，没有千分位隔开，不好数自己的钱，\n互利网中也是如此。\n我们需要将数字整数部分加千分位，小数部分加千分位没必要，一般只精确到后两位。\n因为js没有后瞻，所以首先大家可以将小数点前面的整数提取出来。\n\n方法如下：\n````javascript\n99999999999'.replace(/\\d{1,3}(?=(\\d{3})+)/g, '$&,');\n````\n\n* `(\\d{3})+`表示一组及以上3的倍数个数字加小数点\n* 然后用正向肯定查找 `(?=)` 包起来，说明 `(\\d{3})+` 只是一个条件\n* `g` 表示匹配多次直到没匹配到结果\n* `$&` 表示 `\\d{1,3}` 正向查找条件成立时匹配到的结果\n\n所以，这个正则匹配过程可以理解成：如果匹配到数字1~3个，如果后面的数字刚好是3的倍数，那就符合规则，`$&`提取再加上千分位符，接着继续匹配，知道读到百位后，已经不能满足`\\d{1,3}` 后才停止匹配。\n\n* [怎么引用replace匹配到的结果](../javascript-reg-1#字符串替代：) 知识点。\n\n## 匹配身份证号码\n\n正则匹配身份证号，根据身份证号码的规律，我们得出以下正则：\n\n````javascript\n(?:1[1-5]|2[1-3]|3[1-7]|4[1-6]|5[0-4]|6[1-5]|71|8[12])(?:(0[1-9])|[1-6][1-9]|70)(?:(0[1-9])|1[0-8]|[2-9][1-9])(?:(?:(19[0-9]{2}|200[0-9]|201[0-7])(?:(?:(?:0[1-9]|1[0-2])(?:0[1-9]|1[0-9]|2[0-8]))|(?:(?:0[13-9]|1[0-2])(?:29|30))|(?:0[13578]|1[02])31))|(?:(?:(19|20)(?:0[48]|[2468][048]|[13579][26]))|2000)0229)(?:[0-9]{3}[0-9X]);\n````\n\n\n### 正则分析\n#### 前六位地址码\n\n百度百科上对于前六位中国大陆居民身份证号码中的地址码的数字编码规则解释：\n{% blockquote %}\n华北地区： 北京市|110000，天津市|120000，河北省|130000，山西省|140000，内蒙古自治区|150000，\n东北地区： 辽宁省|210000，吉林省|220000，黑龙江省|230000，\n华东地区： 上海市|310000，江苏省|320000，浙江省|330000，安徽省|340000，福建省|350000，江西省|360000，山东省|370000，\n华中地区： 河南省|410000，湖北省|420000，湖南省|430000，\n华南地区： 广东省|440000，广西壮族自治区|450000，海南省|460000，\n西南地区： 四川省|510000，贵州省|520000，云南省|530000，西藏自治区|540000，重庆市|500000，\n西北地区： 陕西省|610000，甘肃省|620000，青海省|630000，宁夏回族自治区|640000，新疆维吾尔自治区|650000，\n特别地区：台湾地区(886)|710000，香港特别行政区（852)|810000，澳门特别行政区（853)|820000\n\n第一、二位表示省（自治区、直辖市、特别行政区）。\n第三、四位表示市（地级市、自治州、盟及国家直辖市所属市辖区和县的汇总码）。其中，01-20，51-70表示省直辖市；21-50表示地区（自治州、盟）。\n第五、六位表示县（市辖区、县级市、旗）。01-18表示市辖区或地区（自治州、盟）辖县级市；21-80表示县（旗）；81-99表示省直辖县级市。\n{% endblockquote %}\n\n根据以上规则得出以下地址码正则：\n* 第一二位省码：`(?:1[1-5]|2[1-3]|3[1-7]|4[1-6]|5[0-4]|6[1-5]|71|8[12])`\n* 第三四位市码：`(?:(0[1-9])|[1-6][1-9]|70)`\n* 第五六位县码：`(?:(0[1-9])|1[0-8]|[2-9][1-9])` \n\n#### 中间八位生日期码\n\n中间八位是生日器码，YYYYMMDD 格式。因为日期不仅有大小月，还有闰年，但是这里只需要19和20开头的闰年，正则长度小了不少。\n首先从每个月都有的1-28号开始\n`(?:0[1-9]|1[0-2])(?:0[1-9]|1[0-9]|2[0-8])`\n\n然后除2月之外都有29号跟30号\n`(?:0[13-9]|1[0-2])(?:29|30)`\n\n接着1、3、5、7、8、10、12月有31号\n`(?:0[13578]|1[02])31`\n\n以上日期码前面再加上年 `(19[0-9]{2}|200[0-9]|201[0-7])`，这样子除了闰年的所有日期就都ok了，最后再来写闰年。\n闰年的规则是能被4整除单不能被100整除，或者能被400整除。这里我们只写19和20开头的的年份。能被4整除不能被100整除的后两位\n`(0[48]|[2468][048]|[13579][26])`\n能被400整除的1900之后也就只有2000符合规则，2400年得过400年。这些年份写好了，再加上0229就ok了。\n最后我我们用`|`连接起来。\n\n 1900到2017年\n`((?:(19[0-9]{2}|200[0-9]|201[0-7])(?:(?:(?:0[1-9]|1[0-2])(?:0[1-9]|1[0-9]|2[0-8]))|(?:(?:0[13-9]|1[0-2])(?:29|30))|(?:0[13578]|1[02])31))|(?:(?:(19|20)(?:0[48]|[2468][048]|[13579][26]))|2000)0229)`\n\n\n#### 最后四位验证码\n有了地区码和日期码，但是一个地方那一天出生的人肯定不止一人，所以就有了后四位。其中倒数第二个数字男的是单数女的双数，最后一位有可能是罗马数字的X：\n````javascript\n([0-9]{3}[0-9X])\n````\n\n","slug":"javascript-reg-2","published":1,"updated":"2017-07-31T08:33:52.008Z","_id":"cj5rrqje70008fkf1hughf1ix","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本文是一篇真这个表达式的高级教程，主要通过一些例子，深入探讨正则表达式的高级功能。</p>\n<p>写好正则首先第一点得对正则的支持都烂熟于心，第二点就是找到我们要取的数据的唯一特点。接下来我们通过几个例子来加强训练。</p>\n<a id=\"more\"></a>\n<h2 id=\"密码强度\"><a href=\"#密码强度\" class=\"headerlink\" title=\"密码强度\"></a>密码强度</h2><h3 id=\"密码必须包含大小写字母和字母和数字，排除特殊自字符，长度在6-12之间\"><a href=\"#密码必须包含大小写字母和字母和数字，排除特殊自字符，长度在6-12之间\" class=\"headerlink\" title=\"密码必须包含大小写字母和字母和数字，排除特殊自字符，长度在6-12之间\"></a>密码必须包含大小写字母和字母和数字，排除特殊自字符，长度在6-12之间</h3><p>用到了前瞻，如果还不清楚可以移步 <a href=\"../javascript-reg-1\">正则基础学习</a></p>\n<p>正则一<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(?!^[a-z]+$)(?!^[<span class=\"number\">0</span><span class=\"number\">-9</span>]+$)(?!^[A-Z]+$)^[a-zA-Z0<span class=\"number\">-9</span>]&#123;<span class=\"number\">6</span>,<span class=\"number\">12</span>&#125;$</span><br></pre></td></tr></table></figure></p>\n<p>其中 <code>(?!)</code> 这种写法是对后面数据的一种限定，过滤匹配的数据。如 <code>(?!2)[0-9]</code> 就是匹配除了2之外的所有数字。</p>\n<p>然后，上面那段正则就可以分以下四段分析，因为<code>(?!)</code>只是限定条件，不匹配结果，所以前面三个<code>(?!)</code>只是三个条件，后面的才是匹配结果：</p>\n<ul>\n<li><code>(?!^[a-z]+$)</code>: 排除纯小写</li>\n<li><code>(?!^[A-Z]+$)</code>: 排除纯大写</li>\n<li><code>(?!^[0-9]+$)</code>: 排除纯数字</li>\n<li><code>^[a-zA-Z0-9]{6,16}$</code>: 匹配6到12个 [a-zA-Z0-9] 范围中字符</li>\n</ul>\n<p>正则二<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])[a-zA-Z0<span class=\"number\">-9</span>]&#123;<span class=\"number\">6</span>,<span class=\"number\">12</span>&#125;$</span><br></pre></td></tr></table></figure></p>\n<p>这段正则是上面的相反逻辑，所以结构有所不一样。上面那段正则是排除，这段正则是限定条件，所以<code>^</code> 跟 <code>$</code> 位置不同。<br>这段正则分以下也三段分析：</p>\n<ul>\n<li><code>^(?=.*\\d)[a-zA-Z0-9]{6,12}$</code>: 匹配大小写字母以及数字，匹配的字符中必须有数字。</li>\n<li><code>^(?=.*[a-z])[a-zA-Z0-9]{6,12}$</code>: 匹配大小写字母以及数字，匹配的字符中必须有小写字母。</li>\n<li><code>^(?=.*[A-Z])[a-zA-Z0-9]{6,12}$</code>:  匹配大小写字母以及数字，匹配的字符中必须有大写字母。</li>\n</ul>\n<h2 id=\"整数部分千分位\"><a href=\"#整数部分千分位\" class=\"headerlink\" title=\"整数部分千分位\"></a>整数部分千分位</h2><p>现实中，土豪的存折里存的钱会是天文数字，没有千分位隔开，不好数自己的钱，<br>互利网中也是如此。<br>我们需要将数字整数部分加千分位，小数部分加千分位没必要，一般只精确到后两位。<br>因为js没有后瞻，所以首先大家可以将小数点前面的整数提取出来。</p>\n<p>方法如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">99999999999</span><span class=\"string\">'.replace(/\\d&#123;1,3&#125;(?=(\\d&#123;3&#125;)+)/g, '</span>$&amp;,<span class=\"string\">');</span></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><code>(\\d{3})+</code>表示一组及以上3的倍数个数字加小数点</li>\n<li>然后用正向肯定查找 <code>(?=)</code> 包起来，说明 <code>(\\d{3})+</code> 只是一个条件</li>\n<li><code>g</code> 表示匹配多次直到没匹配到结果</li>\n<li><code>$&amp;</code> 表示 <code>\\d{1,3}</code> 正向查找条件成立时匹配到的结果</li>\n</ul>\n<p>所以，这个正则匹配过程可以理解成：如果匹配到数字1~3个，如果后面的数字刚好是3的倍数，那就符合规则，<code>$&amp;</code>提取再加上千分位符，接着继续匹配，知道读到百位后，已经不能满足<code>\\d{1,3}</code> 后才停止匹配。</p>\n<ul>\n<li><a href=\"../javascript-reg-1#字符串替代：\">怎么引用replace匹配到的结果</a> 知识点。</li>\n</ul>\n<h2 id=\"匹配身份证号码\"><a href=\"#匹配身份证号码\" class=\"headerlink\" title=\"匹配身份证号码\"></a>匹配身份证号码</h2><p>正则匹配身份证号，根据身份证号码的规律，我们得出以下正则：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(?:<span class=\"number\">1</span>[<span class=\"number\">1</span><span class=\"number\">-5</span>]|<span class=\"number\">2</span>[<span class=\"number\">1</span><span class=\"number\">-3</span>]|<span class=\"number\">3</span>[<span class=\"number\">1</span><span class=\"number\">-7</span>]|<span class=\"number\">4</span>[<span class=\"number\">1</span><span class=\"number\">-6</span>]|<span class=\"number\">5</span>[<span class=\"number\">0</span><span class=\"number\">-4</span>]|<span class=\"number\">6</span>[<span class=\"number\">1</span><span class=\"number\">-5</span>]|<span class=\"number\">71</span>|<span class=\"number\">8</span>[<span class=\"number\">12</span>])(?:(<span class=\"number\">0</span>[<span class=\"number\">1</span><span class=\"number\">-9</span>])|[<span class=\"number\">1</span><span class=\"number\">-6</span>][<span class=\"number\">1</span><span class=\"number\">-9</span>]|<span class=\"number\">70</span>)(?:(<span class=\"number\">0</span>[<span class=\"number\">1</span><span class=\"number\">-9</span>])|<span class=\"number\">1</span>[<span class=\"number\">0</span><span class=\"number\">-8</span>]|[<span class=\"number\">2</span><span class=\"number\">-9</span>][<span class=\"number\">1</span><span class=\"number\">-9</span>])(?:(?:(<span class=\"number\">19</span>[<span class=\"number\">0</span><span class=\"number\">-9</span>]&#123;<span class=\"number\">2</span>&#125;|<span class=\"number\">200</span>[<span class=\"number\">0</span><span class=\"number\">-9</span>]|<span class=\"number\">201</span>[<span class=\"number\">0</span><span class=\"number\">-7</span>])(?:(?:(?:<span class=\"number\">0</span>[<span class=\"number\">1</span><span class=\"number\">-9</span>]|<span class=\"number\">1</span>[<span class=\"number\">0</span><span class=\"number\">-2</span>])(?:<span class=\"number\">0</span>[<span class=\"number\">1</span><span class=\"number\">-9</span>]|<span class=\"number\">1</span>[<span class=\"number\">0</span><span class=\"number\">-9</span>]|<span class=\"number\">2</span>[<span class=\"number\">0</span><span class=\"number\">-8</span>]))|(?:(?:<span class=\"number\">0</span>[<span class=\"number\">13</span><span class=\"number\">-9</span>]|<span class=\"number\">1</span>[<span class=\"number\">0</span><span class=\"number\">-2</span>])(?:<span class=\"number\">29</span>|<span class=\"number\">30</span>))|(?:<span class=\"number\">0</span>[<span class=\"number\">13578</span>]|<span class=\"number\">1</span>[<span class=\"number\">02</span>])<span class=\"number\">31</span>))|(?:(?:(<span class=\"number\">19</span>|<span class=\"number\">20</span>)(?:<span class=\"number\">0</span>[<span class=\"number\">48</span>]|[<span class=\"number\">2468</span>][<span class=\"number\">048</span>]|[<span class=\"number\">13579</span>][<span class=\"number\">26</span>]))|<span class=\"number\">2000</span>)<span class=\"number\">0229</span>)(?:[<span class=\"number\">0</span><span class=\"number\">-9</span>]&#123;<span class=\"number\">3</span>&#125;[<span class=\"number\">0</span><span class=\"number\">-9</span>X]);</span><br></pre></td></tr></table></figure>\n<h3 id=\"正则分析\"><a href=\"#正则分析\" class=\"headerlink\" title=\"正则分析\"></a>正则分析</h3><h4 id=\"前六位地址码\"><a href=\"#前六位地址码\" class=\"headerlink\" title=\"前六位地址码\"></a>前六位地址码</h4><p>百度百科上对于前六位中国大陆居民身份证号码中的地址码的数字编码规则解释：<br><blockquote><p>华北地区： 北京市|110000，天津市|120000，河北省|130000，山西省|140000，内蒙古自治区|150000，<br>东北地区： 辽宁省|210000，吉林省|220000，黑龙江省|230000，<br>华东地区： 上海市|310000，江苏省|320000，浙江省|330000，安徽省|340000，福建省|350000，江西省|360000，山东省|370000，<br>华中地区： 河南省|410000，湖北省|420000，湖南省|430000，<br>华南地区： 广东省|440000，广西壮族自治区|450000，海南省|460000，<br>西南地区： 四川省|510000，贵州省|520000，云南省|530000，西藏自治区|540000，重庆市|500000，<br>西北地区： 陕西省|610000，甘肃省|620000，青海省|630000，宁夏回族自治区|640000，新疆维吾尔自治区|650000，<br>特别地区：台湾地区(886)|710000，香港特别行政区（852)|810000，澳门特别行政区（853)|820000</p>\n<p>第一、二位表示省（自治区、直辖市、特别行政区）。<br>第三、四位表示市（地级市、自治州、盟及国家直辖市所属市辖区和县的汇总码）。其中，01-20，51-70表示省直辖市；21-50表示地区（自治州、盟）。<br>第五、六位表示县（市辖区、县级市、旗）。01-18表示市辖区或地区（自治州、盟）辖县级市；21-80表示县（旗）；81-99表示省直辖县级市。</p>\n</blockquote></p>\n<p>根据以上规则得出以下地址码正则：</p>\n<ul>\n<li>第一二位省码：<code>(?:1[1-5]|2[1-3]|3[1-7]|4[1-6]|5[0-4]|6[1-5]|71|8[12])</code></li>\n<li>第三四位市码：<code>(?:(0[1-9])|[1-6][1-9]|70)</code></li>\n<li>第五六位县码：<code>(?:(0[1-9])|1[0-8]|[2-9][1-9])</code> </li>\n</ul>\n<h4 id=\"中间八位生日期码\"><a href=\"#中间八位生日期码\" class=\"headerlink\" title=\"中间八位生日期码\"></a>中间八位生日期码</h4><p>中间八位是生日器码，YYYYMMDD 格式。因为日期不仅有大小月，还有闰年，但是这里只需要19和20开头的闰年，正则长度小了不少。<br>首先从每个月都有的1-28号开始<br><code>(?:0[1-9]|1[0-2])(?:0[1-9]|1[0-9]|2[0-8])</code></p>\n<p>然后除2月之外都有29号跟30号<br><code>(?:0[13-9]|1[0-2])(?:29|30)</code></p>\n<p>接着1、3、5、7、8、10、12月有31号<br><code>(?:0[13578]|1[02])31</code></p>\n<p>以上日期码前面再加上年 <code>(19[0-9]{2}|200[0-9]|201[0-7])</code>，这样子除了闰年的所有日期就都ok了，最后再来写闰年。<br>闰年的规则是能被4整除单不能被100整除，或者能被400整除。这里我们只写19和20开头的的年份。能被4整除不能被100整除的后两位<br><code>(0[48]|[2468][048]|[13579][26])</code><br>能被400整除的1900之后也就只有2000符合规则，2400年得过400年。这些年份写好了，再加上0229就ok了。<br>最后我我们用<code>|</code>连接起来。</p>\n<p> 1900到2017年<br><code>((?:(19[0-9]{2}|200[0-9]|201[0-7])(?:(?:(?:0[1-9]|1[0-2])(?:0[1-9]|1[0-9]|2[0-8]))|(?:(?:0[13-9]|1[0-2])(?:29|30))|(?:0[13578]|1[02])31))|(?:(?:(19|20)(?:0[48]|[2468][048]|[13579][26]))|2000)0229)</code></p>\n<h4 id=\"最后四位验证码\"><a href=\"#最后四位验证码\" class=\"headerlink\" title=\"最后四位验证码\"></a>最后四位验证码</h4><p>有了地区码和日期码，但是一个地方那一天出生的人肯定不止一人，所以就有了后四位。其中倒数第二个数字男的是单数女的双数，最后一位有可能是罗马数字的X：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">([<span class=\"number\">0</span><span class=\"number\">-9</span>]&#123;<span class=\"number\">3</span>&#125;[<span class=\"number\">0</span><span class=\"number\">-9</span>X])</span><br></pre></td></tr></table></figure></p>\n","excerpt":"<p>本文是一篇真这个表达式的高级教程，主要通过一些例子，深入探讨正则表达式的高级功能。</p>\n<p>写好正则首先第一点得对正则的支持都烂熟于心，第二点就是找到我们要取的数据的唯一特点。接下来我们通过几个例子来加强训练。</p>","more":"<h2 id=\"密码强度\"><a href=\"#密码强度\" class=\"headerlink\" title=\"密码强度\"></a>密码强度</h2><h3 id=\"密码必须包含大小写字母和字母和数字，排除特殊自字符，长度在6-12之间\"><a href=\"#密码必须包含大小写字母和字母和数字，排除特殊自字符，长度在6-12之间\" class=\"headerlink\" title=\"密码必须包含大小写字母和字母和数字，排除特殊自字符，长度在6-12之间\"></a>密码必须包含大小写字母和字母和数字，排除特殊自字符，长度在6-12之间</h3><p>用到了前瞻，如果还不清楚可以移步 <a href=\"../javascript-reg-1\">正则基础学习</a></p>\n<p>正则一<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(?!^[a-z]+$)(?!^[<span class=\"number\">0</span><span class=\"number\">-9</span>]+$)(?!^[A-Z]+$)^[a-zA-Z0<span class=\"number\">-9</span>]&#123;<span class=\"number\">6</span>,<span class=\"number\">12</span>&#125;$</span><br></pre></td></tr></table></figure></p>\n<p>其中 <code>(?!)</code> 这种写法是对后面数据的一种限定，过滤匹配的数据。如 <code>(?!2)[0-9]</code> 就是匹配除了2之外的所有数字。</p>\n<p>然后，上面那段正则就可以分以下四段分析，因为<code>(?!)</code>只是限定条件，不匹配结果，所以前面三个<code>(?!)</code>只是三个条件，后面的才是匹配结果：</p>\n<ul>\n<li><code>(?!^[a-z]+$)</code>: 排除纯小写</li>\n<li><code>(?!^[A-Z]+$)</code>: 排除纯大写</li>\n<li><code>(?!^[0-9]+$)</code>: 排除纯数字</li>\n<li><code>^[a-zA-Z0-9]{6,16}$</code>: 匹配6到12个 [a-zA-Z0-9] 范围中字符</li>\n</ul>\n<p>正则二<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])[a-zA-Z0<span class=\"number\">-9</span>]&#123;<span class=\"number\">6</span>,<span class=\"number\">12</span>&#125;$</span><br></pre></td></tr></table></figure></p>\n<p>这段正则是上面的相反逻辑，所以结构有所不一样。上面那段正则是排除，这段正则是限定条件，所以<code>^</code> 跟 <code>$</code> 位置不同。<br>这段正则分以下也三段分析：</p>\n<ul>\n<li><code>^(?=.*\\d)[a-zA-Z0-9]{6,12}$</code>: 匹配大小写字母以及数字，匹配的字符中必须有数字。</li>\n<li><code>^(?=.*[a-z])[a-zA-Z0-9]{6,12}$</code>: 匹配大小写字母以及数字，匹配的字符中必须有小写字母。</li>\n<li><code>^(?=.*[A-Z])[a-zA-Z0-9]{6,12}$</code>:  匹配大小写字母以及数字，匹配的字符中必须有大写字母。</li>\n</ul>\n<h2 id=\"整数部分千分位\"><a href=\"#整数部分千分位\" class=\"headerlink\" title=\"整数部分千分位\"></a>整数部分千分位</h2><p>现实中，土豪的存折里存的钱会是天文数字，没有千分位隔开，不好数自己的钱，<br>互利网中也是如此。<br>我们需要将数字整数部分加千分位，小数部分加千分位没必要，一般只精确到后两位。<br>因为js没有后瞻，所以首先大家可以将小数点前面的整数提取出来。</p>\n<p>方法如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">99999999999</span><span class=\"string\">'.replace(/\\d&#123;1,3&#125;(?=(\\d&#123;3&#125;)+)/g, '</span>$&amp;,<span class=\"string\">');</span></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><code>(\\d{3})+</code>表示一组及以上3的倍数个数字加小数点</li>\n<li>然后用正向肯定查找 <code>(?=)</code> 包起来，说明 <code>(\\d{3})+</code> 只是一个条件</li>\n<li><code>g</code> 表示匹配多次直到没匹配到结果</li>\n<li><code>$&amp;</code> 表示 <code>\\d{1,3}</code> 正向查找条件成立时匹配到的结果</li>\n</ul>\n<p>所以，这个正则匹配过程可以理解成：如果匹配到数字1~3个，如果后面的数字刚好是3的倍数，那就符合规则，<code>$&amp;</code>提取再加上千分位符，接着继续匹配，知道读到百位后，已经不能满足<code>\\d{1,3}</code> 后才停止匹配。</p>\n<ul>\n<li><a href=\"../javascript-reg-1#字符串替代：\">怎么引用replace匹配到的结果</a> 知识点。</li>\n</ul>\n<h2 id=\"匹配身份证号码\"><a href=\"#匹配身份证号码\" class=\"headerlink\" title=\"匹配身份证号码\"></a>匹配身份证号码</h2><p>正则匹配身份证号，根据身份证号码的规律，我们得出以下正则：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(?:<span class=\"number\">1</span>[<span class=\"number\">1</span><span class=\"number\">-5</span>]|<span class=\"number\">2</span>[<span class=\"number\">1</span><span class=\"number\">-3</span>]|<span class=\"number\">3</span>[<span class=\"number\">1</span><span class=\"number\">-7</span>]|<span class=\"number\">4</span>[<span class=\"number\">1</span><span class=\"number\">-6</span>]|<span class=\"number\">5</span>[<span class=\"number\">0</span><span class=\"number\">-4</span>]|<span class=\"number\">6</span>[<span class=\"number\">1</span><span class=\"number\">-5</span>]|<span class=\"number\">71</span>|<span class=\"number\">8</span>[<span class=\"number\">12</span>])(?:(<span class=\"number\">0</span>[<span class=\"number\">1</span><span class=\"number\">-9</span>])|[<span class=\"number\">1</span><span class=\"number\">-6</span>][<span class=\"number\">1</span><span class=\"number\">-9</span>]|<span class=\"number\">70</span>)(?:(<span class=\"number\">0</span>[<span class=\"number\">1</span><span class=\"number\">-9</span>])|<span class=\"number\">1</span>[<span class=\"number\">0</span><span class=\"number\">-8</span>]|[<span class=\"number\">2</span><span class=\"number\">-9</span>][<span class=\"number\">1</span><span class=\"number\">-9</span>])(?:(?:(<span class=\"number\">19</span>[<span class=\"number\">0</span><span class=\"number\">-9</span>]&#123;<span class=\"number\">2</span>&#125;|<span class=\"number\">200</span>[<span class=\"number\">0</span><span class=\"number\">-9</span>]|<span class=\"number\">201</span>[<span class=\"number\">0</span><span class=\"number\">-7</span>])(?:(?:(?:<span class=\"number\">0</span>[<span class=\"number\">1</span><span class=\"number\">-9</span>]|<span class=\"number\">1</span>[<span class=\"number\">0</span><span class=\"number\">-2</span>])(?:<span class=\"number\">0</span>[<span class=\"number\">1</span><span class=\"number\">-9</span>]|<span class=\"number\">1</span>[<span class=\"number\">0</span><span class=\"number\">-9</span>]|<span class=\"number\">2</span>[<span class=\"number\">0</span><span class=\"number\">-8</span>]))|(?:(?:<span class=\"number\">0</span>[<span class=\"number\">13</span><span class=\"number\">-9</span>]|<span class=\"number\">1</span>[<span class=\"number\">0</span><span class=\"number\">-2</span>])(?:<span class=\"number\">29</span>|<span class=\"number\">30</span>))|(?:<span class=\"number\">0</span>[<span class=\"number\">13578</span>]|<span class=\"number\">1</span>[<span class=\"number\">02</span>])<span class=\"number\">31</span>))|(?:(?:(<span class=\"number\">19</span>|<span class=\"number\">20</span>)(?:<span class=\"number\">0</span>[<span class=\"number\">48</span>]|[<span class=\"number\">2468</span>][<span class=\"number\">048</span>]|[<span class=\"number\">13579</span>][<span class=\"number\">26</span>]))|<span class=\"number\">2000</span>)<span class=\"number\">0229</span>)(?:[<span class=\"number\">0</span><span class=\"number\">-9</span>]&#123;<span class=\"number\">3</span>&#125;[<span class=\"number\">0</span><span class=\"number\">-9</span>X]);</span><br></pre></td></tr></table></figure>\n<h3 id=\"正则分析\"><a href=\"#正则分析\" class=\"headerlink\" title=\"正则分析\"></a>正则分析</h3><h4 id=\"前六位地址码\"><a href=\"#前六位地址码\" class=\"headerlink\" title=\"前六位地址码\"></a>前六位地址码</h4><p>百度百科上对于前六位中国大陆居民身份证号码中的地址码的数字编码规则解释：<br><blockquote><p>华北地区： 北京市|110000，天津市|120000，河北省|130000，山西省|140000，内蒙古自治区|150000，<br>东北地区： 辽宁省|210000，吉林省|220000，黑龙江省|230000，<br>华东地区： 上海市|310000，江苏省|320000，浙江省|330000，安徽省|340000，福建省|350000，江西省|360000，山东省|370000，<br>华中地区： 河南省|410000，湖北省|420000，湖南省|430000，<br>华南地区： 广东省|440000，广西壮族自治区|450000，海南省|460000，<br>西南地区： 四川省|510000，贵州省|520000，云南省|530000，西藏自治区|540000，重庆市|500000，<br>西北地区： 陕西省|610000，甘肃省|620000，青海省|630000，宁夏回族自治区|640000，新疆维吾尔自治区|650000，<br>特别地区：台湾地区(886)|710000，香港特别行政区（852)|810000，澳门特别行政区（853)|820000</p>\n<p>第一、二位表示省（自治区、直辖市、特别行政区）。<br>第三、四位表示市（地级市、自治州、盟及国家直辖市所属市辖区和县的汇总码）。其中，01-20，51-70表示省直辖市；21-50表示地区（自治州、盟）。<br>第五、六位表示县（市辖区、县级市、旗）。01-18表示市辖区或地区（自治州、盟）辖县级市；21-80表示县（旗）；81-99表示省直辖县级市。</p>\n</blockquote></p>\n<p>根据以上规则得出以下地址码正则：</p>\n<ul>\n<li>第一二位省码：<code>(?:1[1-5]|2[1-3]|3[1-7]|4[1-6]|5[0-4]|6[1-5]|71|8[12])</code></li>\n<li>第三四位市码：<code>(?:(0[1-9])|[1-6][1-9]|70)</code></li>\n<li>第五六位县码：<code>(?:(0[1-9])|1[0-8]|[2-9][1-9])</code> </li>\n</ul>\n<h4 id=\"中间八位生日期码\"><a href=\"#中间八位生日期码\" class=\"headerlink\" title=\"中间八位生日期码\"></a>中间八位生日期码</h4><p>中间八位是生日器码，YYYYMMDD 格式。因为日期不仅有大小月，还有闰年，但是这里只需要19和20开头的闰年，正则长度小了不少。<br>首先从每个月都有的1-28号开始<br><code>(?:0[1-9]|1[0-2])(?:0[1-9]|1[0-9]|2[0-8])</code></p>\n<p>然后除2月之外都有29号跟30号<br><code>(?:0[13-9]|1[0-2])(?:29|30)</code></p>\n<p>接着1、3、5、7、8、10、12月有31号<br><code>(?:0[13578]|1[02])31</code></p>\n<p>以上日期码前面再加上年 <code>(19[0-9]{2}|200[0-9]|201[0-7])</code>，这样子除了闰年的所有日期就都ok了，最后再来写闰年。<br>闰年的规则是能被4整除单不能被100整除，或者能被400整除。这里我们只写19和20开头的的年份。能被4整除不能被100整除的后两位<br><code>(0[48]|[2468][048]|[13579][26])</code><br>能被400整除的1900之后也就只有2000符合规则，2400年得过400年。这些年份写好了，再加上0229就ok了。<br>最后我我们用<code>|</code>连接起来。</p>\n<p> 1900到2017年<br><code>((?:(19[0-9]{2}|200[0-9]|201[0-7])(?:(?:(?:0[1-9]|1[0-2])(?:0[1-9]|1[0-9]|2[0-8]))|(?:(?:0[13-9]|1[0-2])(?:29|30))|(?:0[13578]|1[02])31))|(?:(?:(19|20)(?:0[48]|[2468][048]|[13579][26]))|2000)0229)</code></p>\n<h4 id=\"最后四位验证码\"><a href=\"#最后四位验证码\" class=\"headerlink\" title=\"最后四位验证码\"></a>最后四位验证码</h4><p>有了地区码和日期码，但是一个地方那一天出生的人肯定不止一人，所以就有了后四位。其中倒数第二个数字男的是单数女的双数，最后一位有可能是罗马数字的X：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">([<span class=\"number\">0</span><span class=\"number\">-9</span>]&#123;<span class=\"number\">3</span>&#125;[<span class=\"number\">0</span><span class=\"number\">-9</span>X])</span><br></pre></td></tr></table></figure></p>"},{"title":"webpack-1.x 总结","date":"2016-02-15T09:25:04.000Z","_content":"\n\n## webpack\n\nwebpack在前端工程中越来越多见，当前流行的vue、react、weex等都推荐webpack作为打包工具。所以在这前端打包工具众多，但是没有一个最好用的时代，这应该是最值得去学习的前端打包工具。\n<!--more-->\n### webpack是什么\n\n{% blockquote  官方解释 https://webpack.github.io/docs/what-is-webpack.html %}\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.\n{% endblockquote %}\n\n{% img [what is webpack] http://om64pi295.bkt.clouddn.com/what-is-webpack.png %}\n\nWebpack是一个模块打包工具，将包含有依赖关系的模块集打包合并。Webpack 不仅支持 CommonJs 和 AMD 的模块定义方式的Js，还可以将css、图片、文本等前端资源视为模板。\n\n### 为什么要webpack\n网站进化成Web app，交互越来越复杂，JavaScript文件体积越来越大。通过 `<script>`标签加载js容易引起冲突、阻塞加载等问题，虽然之后出现了RequireJs、Seajs等模块载入框架解决了以上问题，随着定义模块以及模块依赖的方法层出不穷，Webpack获得追捧 。Webpack不仅支持支持多种模块系统风格，而且也支持分段加载、延迟加载等功能，可谓集大成者。\n\n## Webpack配置\n**Webpack 的三个核心概念**\n\n1.**loader**：通过各种资源转换器，将它们转换成对应模块引入\n2.**chunk**：实现按需加载，避免Js文件过大导致阻塞加载。\n\n### 安装配置\n**第一步：Node.js**\n\nwebpack 是 Node 实现，首先需要到 Node.js 下载安装最新版本的 Node.js\n\n**第二步：全局安装webpack-和webpack-dev-server**\n\n```bash\n// -g 参数表示全局安装\n$ npm i -g webpack webpack-dev-server\n```\n\n**第三步：新建前端项目以及安装webpack**\n\n```\n├── index.html      // 入口 HTML  \n├── main.js         // 入口 JS\n```\n\n````html\n<html>\n  <body>\n    <script type=\"text/javascript\" src=\"bundle.js\"></script>\n  </body>\n</html>\n````\n\n````js\ndocument.write('<h1>Hello World</h1>');\n````\n\n**第四步：在项目中安装webpack**\n````bash\n// 初始化 package.json,  根据提示填写 package.json 的相关信息\n$ npm init\n\n// 下载 webpack 依赖 \n// --save-dev 表示将依赖添加到 package.json 中的 'devDependencies' 对象中\n$  npm install webpack --save-dev\n````\n\n**第五步 调用**\n**命令行调用**\n````bash\nwebpack main.js\n````\n\n````bash\nHash: 000934e5d93f498db0f5\nVersion: webpack 1.14.0\nTime: 49ms\n    Asset     Size  Chunks             Chunk Names\nbundle.js  1.57 kB       0  [emitted]  main\n   [0] multi main 40 bytes {0} [built]\n   [1] ./main.js 41 bytes {0} [built]\n````\n\n执行后，可在浏览器打开 index.html\n\n**通过配置文件执行**\n\n````bash\nmodule.exports = {\n  entry: './main.js',\n  output: {\n    filename: 'bundle.js'\n  }\n};\n\n````\n\n文件编译执行\n\n````bash\nwebpack\n````\n\n内存编译执行\n\n````bash\nwebpack-dev-server\n````\n\n一般我们都是通过配置文件投入生产，我们可以在配置指定多个入口文件、代码分离、暴露JS全局变量、编译CSS、压缩图片等等。阮老师做了一个 {% link webpack-demo https://github.com/ruanyf/webpack-demos webpack-demo %}写了很多简单的例子，是份不错的学习资料。所以这篇文章就不再介绍基本用法了。\n\n\n## Chunk\n### Chunk是什么？\nwebpack中 Chunk 实际上就是输出的 .js 文件，可能包含多个模块，主要的作用是为了优化异步加载。\n### Chuck包含了哪些内容\n* 同步情况下：一个 Check 会把模块中的所有依赖都加载到 Chunk 中\n* 异步情况下：所有被切割点分开的依赖被加载到一个 Chunk\n\n**require.ensure跟require都会被加载到一个 Chunk中**\n\n### Chunk 分类\n第三方库不需要打包到发布的文件中，这是几需要vendor，将第三方库打包成一个chunk。\n\nwebpack将chunk类型分为三种**Entry chunk**，**Normal chunk**，**Initial chunk**。\n**Entry Chunk**\n包括两部分代码：webpack运行代码（如webpackJsonp, __webpack_require__ 等函数）和模块代码。\n\n**Normal Chunk**\n只包含模块代码\n\n**Initial  Chunk**\n本质上为Normal Chunk。但是他计算载入时间，比Normal Chunk更重要。一般在使用 CommonsChunkPlugin 时出现。\n\nwebpack 可以将代码切割成不同的 chunk，实现按需加载。\n\n\n## loaders\n\n\n### 什么是loaders \n{% blockquote %}\nLoaders are transformations that are applied on a resource file of your app. They are functions (running in node.js) that take the source of a resource file as the parameter and return the new source.\n{% endblockquote %}\n\n意思就是在webpack中，通过loader可以显示静态资源的转换。\n\n### loader 功能\n\n1. loader 管道：在同一种类型的源文件上，可以同时执行多个 loader ， loader 的执行方式可以类似管道的方式，管道执行的方式是从右到左的方式loader 可以支持同步和异步\n2. loader 可以接收配置参数\n\n3. loader 可以通过正则表达式或者文件后缀指定特定类型的源文件\n\n4. 插件可以提供给 loader 更多功能\n\n5. loader 除了做文件转换以外，还可以创建额外的文件\n\n### loader 配置\n在webpack.config.js 的module.loaders数组中新增一个loader配置。\n\n一个 loader 的配置：\n```` js\n{\n    // 通过扩展名称和正则表单时来匹配资源文件\n    test: String,\n    loader: String | Array,\n    query: String | Object\n}\n\n````\n### 使用 loader\n\n**第一步：安装**\nloader 和 webpack 一样都是Node.js实现，发布到 npm 当中，需要使用loader的时候，只需要如下安装\n````bash\n$ npm install xx-loader --save-dev\n\n// eg css loader\n$ npm install css-loader style-loader --save-dev\n````\n**第二步：修改配置**\n````js\n{\n    entry: {\n        index: './src/index.js',\n        a: './src/a.js'\n    },\n    output: {\n        path: './dist/',\n        filename: '[name].js'\n    },\n    module: {\n        loaders: [{\n            test: /\\.js$/,\n            exclude: /node_modules/,\n            loader: 'babel',\n            query: {\n                presets: ['es2015', 'stage-0', 'react']\n            }\n        }, {\n            test: /\\.css$/, \n            loader: \"style-loader!css-loader\" \n        }]\n    }\n}\n````\n\n**第三步：使用**\n\n前面我们已经使用过 jsx loader 了， loader 的使用方式有多种\n\n1. 在配置文件中配置\n\n2. 显示的通过 require 调用\n\n3. 命令行调用\n\n__显示的调用 require 会增加模块的耦合度，应尽量避免这种方式__\n\n\nsrc/style.css\n\n````css\nbody {\n    background: red;\n    color: white;\n}\n````\n修改 webpack 配置 entry 添加\n````js\nentry: {\n    index: ['./index.js', './style.css']\n}\n````\n最终的编译结果会将  css 被转化为了 javascript。\n\n另一种方法是直接 require，修改./index.js:\n````js\nvar css = require(\"css!./style.css\");\n````\n结果一样\n\n## 常用Loaders\n### 加载 CSS\n加载css需要 `css-loader`和`style-loader`，分别做以下两件事：\n1. css-loader 会遍历 CSS 文件，然后找到 url() 表达式然后处理他们\n2. style-loader 会把原来的 CSS 代码插入页面中的一个 style 标签中\n````js\n{\n  // loader配置\n    test: /\\.css$/,\n    loader: 'style!css' // 如果同时使用多个加载器，中间用 ! 连接，加载器的执行顺序是从右向左\n  }\n````\n### 图片处理\n图片处理需要 `url-loader` 和 `file-loader`\n````js\n{\n  // loader配置\n  test: /\\.(png|jpg|gif|jpeg)$/,\n  loader: 'url?limit=25000'\n}\n````\n传入的 limit 参数是告诉它图片如果不大于 25KB 的话要自动在它从属的 css 文件中转成 BASE64 字符串。\n\n#### eslint\n````js\n  module : {\n    preLoaders: [\n        {test: /\\.js$/, loader: \"eslint-loader\", exclude: /node_modules/}\n    ],\n  }\n````\n\n## 常用Plugin\n###UglifyJsPlugin webpack自带的插件\n一般配置如下：\n````js\n  plugins: [\n    new webpack.optimize.UglifyJsPlugin({\n          compress: {\n              warnings: false\n          }\n      })\n  ]\n````\n\n### extractTextWebpackPlugin\n在webpack中，可以通过require引入css，通过loader对文件自动解析并打包文件。通常会将css以在页面的header切入style形式加载样式。但是我们如果你想通过外链形式加载css的话，通过extract-text-webpack-plugin就可以办到。\n````js\nvar ExtractTextPlugin = require(\"extract-text-webpack-plugin\");\nplugins: [\n  new ExtractTextPlugin(\"app.css\")\n]\n````\n\n### htmlWebpackPlugin\n生成HTML\n\n````js\nconst path = require('path');\n\nconst HTMLWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  entry: {\n    index: './pages/index.js',\n    page1: './pages/page1.js',\n    page2: './pages/page2.js'\n  },\n  output: {\n    path: path.join(__dirname, 'dist'),\n    filename: '[name].js'\n  },\n  plugins: [\n    new HTMLWebpackPlugin({\n      filename: 'index.html',\n      template: 'templates/index.html',\n      inject: true,\n      chunks: ['index']\n    }),\n    new HTMLWebpackPlugin({\n      filename: 'page1.html',\n      template: 'templates/page1.html',\n      inject: true,\n      chunks: ['page1']\n    }),\n    new HTMLWebpackPlugin({\n      filename: 'page2.html',\n      template: 'templates/page2.html',\n      inject: true,\n      chunks: ['page2']\n    })\n  ]\n};\n````\n\n\n#### 提取公共Js插件\n通过 `CommonsChunkPlugin` 可以将个模块的公共依赖单独打包成一个 chunk，这时webpack的运行代码会被移到`common chunk` 中，原来的 `entry chunk` 也降变为 `initial chunk`。\n\n`entry vendor`配合`CommonsChunkPlugin`使用，可以分离第三方库和app代码。\n\n````js\nentry: {\n   app: './app.js',\n   vendor: ['jquery', 'lodash']\n},\nplugins: {\n    new webpack.optimize.CommonsChunkPlugin('vendor', 'vendor.bundle.js')   \n}\n````\n\n这样子的话，app.js 只包含依赖的JS，但是对第三方依赖的都被排除掉了。第三方库被打包成 `vendor.bundle.js`。\n\n**CommonsChunkPlugin配置项：**\n\n- names: chunk的名称，字符串或数组。\n- filename: chunk文件名称，默认为output.filename或者output.chunkFilename\n- minChunks 被几个chunk调用的moudule才会加入common chunk中，最小值为2。如果设置为Infinity，则不会有module加入到common chunk中\nchunks: 需要提前common的源文件，默认为全部入口文件。\n- children: 如果设置为 `true`，所有  公共chunk 的子模块都会被选择\n- async:  如果设置为 `true`，一个异步的  公共chunk 会作为 `options.name` 的子模块，和 `options.chunks` 的兄弟模块被创建。 它会与 `options.chunks` 并行被加载。可以通过提供想要的字符串，而不是 `true` 来对输出的文件进行更换名称。\n- minSize: 在 公共chunk 被创建立之前，所有 公共模块 (common module) 的最少大小。\n\n#### ProvidePlugin插件\n将模块暴露到全局\n\n````js\nnew webpack.ProvidePlugin({\n    \"R\": \"report\",\n}),\n````\n\n#### 删除目录插件\nclean-webpack-plugin\n````js\n\n  var CleanPlugin = require(\"clean-webpack-plugin\");\n  plugins: [\n    new CleanPlugin(['dist']),\n  ]\n````\n#### 拷贝文件插件\n\ncopy-webpack-plugin\n````js\nvar CopyWebpackPlugin = require('copy-webpack-plugin');\nplugins: [\n  new CopyWebpackPlugin([{\n    from: __dirname + '/src/public'\n  }])\n]\n````\n\n\n#### 优化第三方包插件\n````js\nplugins: [\n  new webpack.DefinePlugin({\n      //去掉react中的警告，react会自己判断\n      'process.env': {\n          NODE_ENV: '\"production\"'\n      }\n  })\n]\n````\n\n#### 自动打开浏览器插件\nopen-browser-webpack-plugin\n````js\n  // 自动打开浏览器插件\n  var OpenBrowserPlugin = require('open-browser-webpack-plugin');\n  plugins: [\n      new OpenBrowserPlugin({url: 'http://localhost:8080/', browser: 'chrome'})\n  ]\n````\n\nplugin 为 webpack 提供了更多的自定义功能。\n就不一一列举了，点击\n {% link webpack-plugins https://github.com/webpack-contrib/awesome-webpack#webpack-plugins %}\n\n\n### Resolve属性\nwebpack 在构建包的时候会按配置进行模块的查找\n````js\n resolve: {\n      //查找module的话从这里开始查找\n      root: '/pomy/github/flux-example/src', //绝对路径\n      //自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名\n      //注意一下, extensions 第一个是空字符串! 对应不需要后缀的情况.\n      extensions: ['', '.js', '.json', '.scss',’jsx’],\n\n      //模块别名定义，方便后续直接引用别名，无须多写长长的地址\n      alias: {\n          AppStore : 'js/stores/AppStores.js',//后续直接 require('AppStore') 即可\n          ActionType : 'js/actions/ActionType.js',\n          AppAction : 'js/actions/AppAction.js'\n      }\n  }\n````\n\n\n\n### Externals属性\n外部依赖不需要打包进 bundle，当我们想在项目中 require 一些其他的类库或者 API ，而又不想让这些类库的源码被构建到运行时文件中，这在实际开发中很有必要。 比如：在页面里通过 script 标签引用了 jQuery：`<script src=\"//code.jquery.com/jquery-1.12.0.min.js\"></script>`，所以并不想在其他 js 里再打包进入一遍，比如你的其他 js 代码类似：\n\n其实就是不是通过require或者import引入的，而是直接写在html中的js地址。\n\n````js\n    // 配置了这个属性之后 react 和 react-dom 这些第三方的包都不会被构建进 js 中，那么我们就需要通过 cdn 进行文件的引用了\n    // 前边的这个名称是在项目中引用用的，相当于 import React from 'react1' 中的 react\n    externals: {\n        'react1': 'react',\n        'react-dom1': 'react-dom',\n        '$1': 'jQuery'\n    }\n````\n\n这样用了 externals 属性时不用分离插件了，作用是这里引的插件不会被 webpack 所打包。要么用 cdn 要么需要 webpack 打包。\n\n### noParse属性\nmodule.noParse 是 webpack 的另一个很有用的配置项，如果确定一个模块中没有其他新的依赖项就可以配置这个像，webpack 将不再扫描这个文件中的依赖。\n````js\n  module: {\n    noParse: [/moment-with-locales/]\n  }\n````","source":"_posts/webpack-1-x.md","raw":"title: webpack-1.x 总结\ndate: 2016-02-15 17:25:04\ntags:\n- webpack\n- webpack1.x\ncategories:\n- 前端构建工具\n---\n\n\n## webpack\n\nwebpack在前端工程中越来越多见，当前流行的vue、react、weex等都推荐webpack作为打包工具。所以在这前端打包工具众多，但是没有一个最好用的时代，这应该是最值得去学习的前端打包工具。\n<!--more-->\n### webpack是什么\n\n{% blockquote  官方解释 https://webpack.github.io/docs/what-is-webpack.html %}\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.\n{% endblockquote %}\n\n{% img [what is webpack] http://om64pi295.bkt.clouddn.com/what-is-webpack.png %}\n\nWebpack是一个模块打包工具，将包含有依赖关系的模块集打包合并。Webpack 不仅支持 CommonJs 和 AMD 的模块定义方式的Js，还可以将css、图片、文本等前端资源视为模板。\n\n### 为什么要webpack\n网站进化成Web app，交互越来越复杂，JavaScript文件体积越来越大。通过 `<script>`标签加载js容易引起冲突、阻塞加载等问题，虽然之后出现了RequireJs、Seajs等模块载入框架解决了以上问题，随着定义模块以及模块依赖的方法层出不穷，Webpack获得追捧 。Webpack不仅支持支持多种模块系统风格，而且也支持分段加载、延迟加载等功能，可谓集大成者。\n\n## Webpack配置\n**Webpack 的三个核心概念**\n\n1.**loader**：通过各种资源转换器，将它们转换成对应模块引入\n2.**chunk**：实现按需加载，避免Js文件过大导致阻塞加载。\n\n### 安装配置\n**第一步：Node.js**\n\nwebpack 是 Node 实现，首先需要到 Node.js 下载安装最新版本的 Node.js\n\n**第二步：全局安装webpack-和webpack-dev-server**\n\n```bash\n// -g 参数表示全局安装\n$ npm i -g webpack webpack-dev-server\n```\n\n**第三步：新建前端项目以及安装webpack**\n\n```\n├── index.html      // 入口 HTML  \n├── main.js         // 入口 JS\n```\n\n````html\n<html>\n  <body>\n    <script type=\"text/javascript\" src=\"bundle.js\"></script>\n  </body>\n</html>\n````\n\n````js\ndocument.write('<h1>Hello World</h1>');\n````\n\n**第四步：在项目中安装webpack**\n````bash\n// 初始化 package.json,  根据提示填写 package.json 的相关信息\n$ npm init\n\n// 下载 webpack 依赖 \n// --save-dev 表示将依赖添加到 package.json 中的 'devDependencies' 对象中\n$  npm install webpack --save-dev\n````\n\n**第五步 调用**\n**命令行调用**\n````bash\nwebpack main.js\n````\n\n````bash\nHash: 000934e5d93f498db0f5\nVersion: webpack 1.14.0\nTime: 49ms\n    Asset     Size  Chunks             Chunk Names\nbundle.js  1.57 kB       0  [emitted]  main\n   [0] multi main 40 bytes {0} [built]\n   [1] ./main.js 41 bytes {0} [built]\n````\n\n执行后，可在浏览器打开 index.html\n\n**通过配置文件执行**\n\n````bash\nmodule.exports = {\n  entry: './main.js',\n  output: {\n    filename: 'bundle.js'\n  }\n};\n\n````\n\n文件编译执行\n\n````bash\nwebpack\n````\n\n内存编译执行\n\n````bash\nwebpack-dev-server\n````\n\n一般我们都是通过配置文件投入生产，我们可以在配置指定多个入口文件、代码分离、暴露JS全局变量、编译CSS、压缩图片等等。阮老师做了一个 {% link webpack-demo https://github.com/ruanyf/webpack-demos webpack-demo %}写了很多简单的例子，是份不错的学习资料。所以这篇文章就不再介绍基本用法了。\n\n\n## Chunk\n### Chunk是什么？\nwebpack中 Chunk 实际上就是输出的 .js 文件，可能包含多个模块，主要的作用是为了优化异步加载。\n### Chuck包含了哪些内容\n* 同步情况下：一个 Check 会把模块中的所有依赖都加载到 Chunk 中\n* 异步情况下：所有被切割点分开的依赖被加载到一个 Chunk\n\n**require.ensure跟require都会被加载到一个 Chunk中**\n\n### Chunk 分类\n第三方库不需要打包到发布的文件中，这是几需要vendor，将第三方库打包成一个chunk。\n\nwebpack将chunk类型分为三种**Entry chunk**，**Normal chunk**，**Initial chunk**。\n**Entry Chunk**\n包括两部分代码：webpack运行代码（如webpackJsonp, __webpack_require__ 等函数）和模块代码。\n\n**Normal Chunk**\n只包含模块代码\n\n**Initial  Chunk**\n本质上为Normal Chunk。但是他计算载入时间，比Normal Chunk更重要。一般在使用 CommonsChunkPlugin 时出现。\n\nwebpack 可以将代码切割成不同的 chunk，实现按需加载。\n\n\n## loaders\n\n\n### 什么是loaders \n{% blockquote %}\nLoaders are transformations that are applied on a resource file of your app. They are functions (running in node.js) that take the source of a resource file as the parameter and return the new source.\n{% endblockquote %}\n\n意思就是在webpack中，通过loader可以显示静态资源的转换。\n\n### loader 功能\n\n1. loader 管道：在同一种类型的源文件上，可以同时执行多个 loader ， loader 的执行方式可以类似管道的方式，管道执行的方式是从右到左的方式loader 可以支持同步和异步\n2. loader 可以接收配置参数\n\n3. loader 可以通过正则表达式或者文件后缀指定特定类型的源文件\n\n4. 插件可以提供给 loader 更多功能\n\n5. loader 除了做文件转换以外，还可以创建额外的文件\n\n### loader 配置\n在webpack.config.js 的module.loaders数组中新增一个loader配置。\n\n一个 loader 的配置：\n```` js\n{\n    // 通过扩展名称和正则表单时来匹配资源文件\n    test: String,\n    loader: String | Array,\n    query: String | Object\n}\n\n````\n### 使用 loader\n\n**第一步：安装**\nloader 和 webpack 一样都是Node.js实现，发布到 npm 当中，需要使用loader的时候，只需要如下安装\n````bash\n$ npm install xx-loader --save-dev\n\n// eg css loader\n$ npm install css-loader style-loader --save-dev\n````\n**第二步：修改配置**\n````js\n{\n    entry: {\n        index: './src/index.js',\n        a: './src/a.js'\n    },\n    output: {\n        path: './dist/',\n        filename: '[name].js'\n    },\n    module: {\n        loaders: [{\n            test: /\\.js$/,\n            exclude: /node_modules/,\n            loader: 'babel',\n            query: {\n                presets: ['es2015', 'stage-0', 'react']\n            }\n        }, {\n            test: /\\.css$/, \n            loader: \"style-loader!css-loader\" \n        }]\n    }\n}\n````\n\n**第三步：使用**\n\n前面我们已经使用过 jsx loader 了， loader 的使用方式有多种\n\n1. 在配置文件中配置\n\n2. 显示的通过 require 调用\n\n3. 命令行调用\n\n__显示的调用 require 会增加模块的耦合度，应尽量避免这种方式__\n\n\nsrc/style.css\n\n````css\nbody {\n    background: red;\n    color: white;\n}\n````\n修改 webpack 配置 entry 添加\n````js\nentry: {\n    index: ['./index.js', './style.css']\n}\n````\n最终的编译结果会将  css 被转化为了 javascript。\n\n另一种方法是直接 require，修改./index.js:\n````js\nvar css = require(\"css!./style.css\");\n````\n结果一样\n\n## 常用Loaders\n### 加载 CSS\n加载css需要 `css-loader`和`style-loader`，分别做以下两件事：\n1. css-loader 会遍历 CSS 文件，然后找到 url() 表达式然后处理他们\n2. style-loader 会把原来的 CSS 代码插入页面中的一个 style 标签中\n````js\n{\n  // loader配置\n    test: /\\.css$/,\n    loader: 'style!css' // 如果同时使用多个加载器，中间用 ! 连接，加载器的执行顺序是从右向左\n  }\n````\n### 图片处理\n图片处理需要 `url-loader` 和 `file-loader`\n````js\n{\n  // loader配置\n  test: /\\.(png|jpg|gif|jpeg)$/,\n  loader: 'url?limit=25000'\n}\n````\n传入的 limit 参数是告诉它图片如果不大于 25KB 的话要自动在它从属的 css 文件中转成 BASE64 字符串。\n\n#### eslint\n````js\n  module : {\n    preLoaders: [\n        {test: /\\.js$/, loader: \"eslint-loader\", exclude: /node_modules/}\n    ],\n  }\n````\n\n## 常用Plugin\n###UglifyJsPlugin webpack自带的插件\n一般配置如下：\n````js\n  plugins: [\n    new webpack.optimize.UglifyJsPlugin({\n          compress: {\n              warnings: false\n          }\n      })\n  ]\n````\n\n### extractTextWebpackPlugin\n在webpack中，可以通过require引入css，通过loader对文件自动解析并打包文件。通常会将css以在页面的header切入style形式加载样式。但是我们如果你想通过外链形式加载css的话，通过extract-text-webpack-plugin就可以办到。\n````js\nvar ExtractTextPlugin = require(\"extract-text-webpack-plugin\");\nplugins: [\n  new ExtractTextPlugin(\"app.css\")\n]\n````\n\n### htmlWebpackPlugin\n生成HTML\n\n````js\nconst path = require('path');\n\nconst HTMLWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  entry: {\n    index: './pages/index.js',\n    page1: './pages/page1.js',\n    page2: './pages/page2.js'\n  },\n  output: {\n    path: path.join(__dirname, 'dist'),\n    filename: '[name].js'\n  },\n  plugins: [\n    new HTMLWebpackPlugin({\n      filename: 'index.html',\n      template: 'templates/index.html',\n      inject: true,\n      chunks: ['index']\n    }),\n    new HTMLWebpackPlugin({\n      filename: 'page1.html',\n      template: 'templates/page1.html',\n      inject: true,\n      chunks: ['page1']\n    }),\n    new HTMLWebpackPlugin({\n      filename: 'page2.html',\n      template: 'templates/page2.html',\n      inject: true,\n      chunks: ['page2']\n    })\n  ]\n};\n````\n\n\n#### 提取公共Js插件\n通过 `CommonsChunkPlugin` 可以将个模块的公共依赖单独打包成一个 chunk，这时webpack的运行代码会被移到`common chunk` 中，原来的 `entry chunk` 也降变为 `initial chunk`。\n\n`entry vendor`配合`CommonsChunkPlugin`使用，可以分离第三方库和app代码。\n\n````js\nentry: {\n   app: './app.js',\n   vendor: ['jquery', 'lodash']\n},\nplugins: {\n    new webpack.optimize.CommonsChunkPlugin('vendor', 'vendor.bundle.js')   \n}\n````\n\n这样子的话，app.js 只包含依赖的JS，但是对第三方依赖的都被排除掉了。第三方库被打包成 `vendor.bundle.js`。\n\n**CommonsChunkPlugin配置项：**\n\n- names: chunk的名称，字符串或数组。\n- filename: chunk文件名称，默认为output.filename或者output.chunkFilename\n- minChunks 被几个chunk调用的moudule才会加入common chunk中，最小值为2。如果设置为Infinity，则不会有module加入到common chunk中\nchunks: 需要提前common的源文件，默认为全部入口文件。\n- children: 如果设置为 `true`，所有  公共chunk 的子模块都会被选择\n- async:  如果设置为 `true`，一个异步的  公共chunk 会作为 `options.name` 的子模块，和 `options.chunks` 的兄弟模块被创建。 它会与 `options.chunks` 并行被加载。可以通过提供想要的字符串，而不是 `true` 来对输出的文件进行更换名称。\n- minSize: 在 公共chunk 被创建立之前，所有 公共模块 (common module) 的最少大小。\n\n#### ProvidePlugin插件\n将模块暴露到全局\n\n````js\nnew webpack.ProvidePlugin({\n    \"R\": \"report\",\n}),\n````\n\n#### 删除目录插件\nclean-webpack-plugin\n````js\n\n  var CleanPlugin = require(\"clean-webpack-plugin\");\n  plugins: [\n    new CleanPlugin(['dist']),\n  ]\n````\n#### 拷贝文件插件\n\ncopy-webpack-plugin\n````js\nvar CopyWebpackPlugin = require('copy-webpack-plugin');\nplugins: [\n  new CopyWebpackPlugin([{\n    from: __dirname + '/src/public'\n  }])\n]\n````\n\n\n#### 优化第三方包插件\n````js\nplugins: [\n  new webpack.DefinePlugin({\n      //去掉react中的警告，react会自己判断\n      'process.env': {\n          NODE_ENV: '\"production\"'\n      }\n  })\n]\n````\n\n#### 自动打开浏览器插件\nopen-browser-webpack-plugin\n````js\n  // 自动打开浏览器插件\n  var OpenBrowserPlugin = require('open-browser-webpack-plugin');\n  plugins: [\n      new OpenBrowserPlugin({url: 'http://localhost:8080/', browser: 'chrome'})\n  ]\n````\n\nplugin 为 webpack 提供了更多的自定义功能。\n就不一一列举了，点击\n {% link webpack-plugins https://github.com/webpack-contrib/awesome-webpack#webpack-plugins %}\n\n\n### Resolve属性\nwebpack 在构建包的时候会按配置进行模块的查找\n````js\n resolve: {\n      //查找module的话从这里开始查找\n      root: '/pomy/github/flux-example/src', //绝对路径\n      //自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名\n      //注意一下, extensions 第一个是空字符串! 对应不需要后缀的情况.\n      extensions: ['', '.js', '.json', '.scss',’jsx’],\n\n      //模块别名定义，方便后续直接引用别名，无须多写长长的地址\n      alias: {\n          AppStore : 'js/stores/AppStores.js',//后续直接 require('AppStore') 即可\n          ActionType : 'js/actions/ActionType.js',\n          AppAction : 'js/actions/AppAction.js'\n      }\n  }\n````\n\n\n\n### Externals属性\n外部依赖不需要打包进 bundle，当我们想在项目中 require 一些其他的类库或者 API ，而又不想让这些类库的源码被构建到运行时文件中，这在实际开发中很有必要。 比如：在页面里通过 script 标签引用了 jQuery：`<script src=\"//code.jquery.com/jquery-1.12.0.min.js\"></script>`，所以并不想在其他 js 里再打包进入一遍，比如你的其他 js 代码类似：\n\n其实就是不是通过require或者import引入的，而是直接写在html中的js地址。\n\n````js\n    // 配置了这个属性之后 react 和 react-dom 这些第三方的包都不会被构建进 js 中，那么我们就需要通过 cdn 进行文件的引用了\n    // 前边的这个名称是在项目中引用用的，相当于 import React from 'react1' 中的 react\n    externals: {\n        'react1': 'react',\n        'react-dom1': 'react-dom',\n        '$1': 'jQuery'\n    }\n````\n\n这样用了 externals 属性时不用分离插件了，作用是这里引的插件不会被 webpack 所打包。要么用 cdn 要么需要 webpack 打包。\n\n### noParse属性\nmodule.noParse 是 webpack 的另一个很有用的配置项，如果确定一个模块中没有其他新的依赖项就可以配置这个像，webpack 将不再扫描这个文件中的依赖。\n````js\n  module: {\n    noParse: [/moment-with-locales/]\n  }\n````","slug":"webpack-1-x","published":1,"updated":"2017-07-31T08:33:54.560Z","_id":"cj5rrqjea000bfkf1pmrd74pp","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"webpack\"><a href=\"#webpack\" class=\"headerlink\" title=\"webpack\"></a>webpack</h2><p>webpack在前端工程中越来越多见，当前流行的vue、react、weex等都推荐webpack作为打包工具。所以在这前端打包工具众多，但是没有一个最好用的时代，这应该是最值得去学习的前端打包工具。<br><a id=\"more\"></a></p>\n<h3 id=\"webpack是什么\"><a href=\"#webpack是什么\" class=\"headerlink\" title=\"webpack是什么\"></a>webpack是什么</h3><blockquote><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.</p>\n<footer><strong>官方解释</strong><cite><a href=\"https://webpack.github.io/docs/what-is-webpack.html\" target=\"_blank\" rel=\"external\">webpack.github.io/docs/what-is-webpack.html</a></cite></footer></blockquote>\n<img src=\"http://om64pi295.bkt.clouddn.com/what-is-webpack.png\" class=\"[what is webpack]\">\n<p>Webpack是一个模块打包工具，将包含有依赖关系的模块集打包合并。Webpack 不仅支持 CommonJs 和 AMD 的模块定义方式的Js，还可以将css、图片、文本等前端资源视为模板。</p>\n<h3 id=\"为什么要webpack\"><a href=\"#为什么要webpack\" class=\"headerlink\" title=\"为什么要webpack\"></a>为什么要webpack</h3><p>网站进化成Web app，交互越来越复杂，JavaScript文件体积越来越大。通过 <code>&lt;script&gt;</code>标签加载js容易引起冲突、阻塞加载等问题，虽然之后出现了RequireJs、Seajs等模块载入框架解决了以上问题，随着定义模块以及模块依赖的方法层出不穷，Webpack获得追捧 。Webpack不仅支持支持多种模块系统风格，而且也支持分段加载、延迟加载等功能，可谓集大成者。</p>\n<h2 id=\"Webpack配置\"><a href=\"#Webpack配置\" class=\"headerlink\" title=\"Webpack配置\"></a>Webpack配置</h2><p><strong>Webpack 的三个核心概念</strong></p>\n<p>1.<strong>loader</strong>：通过各种资源转换器，将它们转换成对应模块引入<br>2.<strong>chunk</strong>：实现按需加载，避免Js文件过大导致阻塞加载。</p>\n<h3 id=\"安装配置\"><a href=\"#安装配置\" class=\"headerlink\" title=\"安装配置\"></a>安装配置</h3><p><strong>第一步：Node.js</strong></p>\n<p>webpack 是 Node 实现，首先需要到 Node.js 下载安装最新版本的 Node.js</p>\n<p><strong>第二步：全局安装webpack-和webpack-dev-server</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// -g 参数表示全局安装</span><br><span class=\"line\">$ npm i -g webpack webpack-dev-server</span><br></pre></td></tr></table></figure>\n<p><strong>第三步：新建前端项目以及安装webpack</strong></p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── index<span class=\"selector-class\">.html</span>      <span class=\"comment\">// 入口 HTML  </span></span><br><span class=\"line\">├── main<span class=\"selector-class\">.js</span>         <span class=\"comment\">// 入口 JS</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"bundle.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">'&lt;h1&gt;Hello World&lt;/h1&gt;'</span>);</span><br></pre></td></tr></table></figure>\n<p><strong>第四步：在项目中安装webpack</strong><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 初始化 package.json,  根据提示填写 package.json 的相关信息</span><br><span class=\"line\">$ npm init</span><br><span class=\"line\"></span><br><span class=\"line\">// 下载 webpack 依赖 </span><br><span class=\"line\">// --save-dev 表示将依赖添加到 package.json 中的 <span class=\"string\">'devDependencies'</span> 对象中</span><br><span class=\"line\">$  npm install webpack --save-dev</span><br></pre></td></tr></table></figure></p>\n<p><strong>第五步 调用</strong><br><strong>命令行调用</strong><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpack main.js</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hash: 000934e5d93f498db0f5</span><br><span class=\"line\">Version: webpack 1.14.0</span><br><span class=\"line\">Time: 49ms</span><br><span class=\"line\">    Asset     Size  Chunks             Chunk Names</span><br><span class=\"line\">bundle.js  1.57 kB       0  [emitted]  main</span><br><span class=\"line\">   [0] multi main 40 bytes &#123;0&#125; [built]</span><br><span class=\"line\">   [1] ./main.js 41 bytes &#123;0&#125; [built]</span><br></pre></td></tr></table></figure>\n<p>执行后，可在浏览器打开 index.html</p>\n<p><strong>通过配置文件执行</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  entry: <span class=\"string\">'./main.js'</span>,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    filename: <span class=\"string\">'bundle.js'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>文件编译执行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpack</span><br></pre></td></tr></table></figure>\n<p>内存编译执行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpack-dev-server</span><br></pre></td></tr></table></figure>\n<p>一般我们都是通过配置文件投入生产，我们可以在配置指定多个入口文件、代码分离、暴露JS全局变量、编译CSS、压缩图片等等。阮老师做了一个 <a href=\"https://github.com/ruanyf/webpack-demos\" title=\"webpack-demo\" target=\"_blank\" rel=\"external\">webpack-demo</a>写了很多简单的例子，是份不错的学习资料。所以这篇文章就不再介绍基本用法了。</p>\n<h2 id=\"Chunk\"><a href=\"#Chunk\" class=\"headerlink\" title=\"Chunk\"></a>Chunk</h2><h3 id=\"Chunk是什么？\"><a href=\"#Chunk是什么？\" class=\"headerlink\" title=\"Chunk是什么？\"></a>Chunk是什么？</h3><p>webpack中 Chunk 实际上就是输出的 .js 文件，可能包含多个模块，主要的作用是为了优化异步加载。</p>\n<h3 id=\"Chuck包含了哪些内容\"><a href=\"#Chuck包含了哪些内容\" class=\"headerlink\" title=\"Chuck包含了哪些内容\"></a>Chuck包含了哪些内容</h3><ul>\n<li>同步情况下：一个 Check 会把模块中的所有依赖都加载到 Chunk 中</li>\n<li>异步情况下：所有被切割点分开的依赖被加载到一个 Chunk</li>\n</ul>\n<p><strong>require.ensure跟require都会被加载到一个 Chunk中</strong></p>\n<h3 id=\"Chunk-分类\"><a href=\"#Chunk-分类\" class=\"headerlink\" title=\"Chunk 分类\"></a>Chunk 分类</h3><p>第三方库不需要打包到发布的文件中，这是几需要vendor，将第三方库打包成一个chunk。</p>\n<p>webpack将chunk类型分为三种<strong>Entry chunk</strong>，<strong>Normal chunk</strong>，<strong>Initial chunk</strong>。<br><strong>Entry Chunk</strong><br>包括两部分代码：webpack运行代码（如webpackJsonp, <strong>webpack_require</strong> 等函数）和模块代码。</p>\n<p><strong>Normal Chunk</strong><br>只包含模块代码</p>\n<p><strong>Initial  Chunk</strong><br>本质上为Normal Chunk。但是他计算载入时间，比Normal Chunk更重要。一般在使用 CommonsChunkPlugin 时出现。</p>\n<p>webpack 可以将代码切割成不同的 chunk，实现按需加载。</p>\n<h2 id=\"loaders\"><a href=\"#loaders\" class=\"headerlink\" title=\"loaders\"></a>loaders</h2><h3 id=\"什么是loaders\"><a href=\"#什么是loaders\" class=\"headerlink\" title=\"什么是loaders\"></a>什么是loaders</h3><blockquote><p>Loaders are transformations that are applied on a resource file of your app. They are functions (running in node.js) that take the source of a resource file as the parameter and return the new source.</p>\n</blockquote>\n<p>意思就是在webpack中，通过loader可以显示静态资源的转换。</p>\n<h3 id=\"loader-功能\"><a href=\"#loader-功能\" class=\"headerlink\" title=\"loader 功能\"></a>loader 功能</h3><ol>\n<li>loader 管道：在同一种类型的源文件上，可以同时执行多个 loader ， loader 的执行方式可以类似管道的方式，管道执行的方式是从右到左的方式loader 可以支持同步和异步</li>\n<li><p>loader 可以接收配置参数</p>\n</li>\n<li><p>loader 可以通过正则表达式或者文件后缀指定特定类型的源文件</p>\n</li>\n<li><p>插件可以提供给 loader 更多功能</p>\n</li>\n<li><p>loader 除了做文件转换以外，还可以创建额外的文件</p>\n</li>\n</ol>\n<h3 id=\"loader-配置\"><a href=\"#loader-配置\" class=\"headerlink\" title=\"loader 配置\"></a>loader 配置</h3><p>在webpack.config.js 的module.loaders数组中新增一个loader配置。</p>\n<p>一个 loader 的配置：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过扩展名称和正则表单时来匹配资源文件</span></span><br><span class=\"line\">    test: <span class=\"built_in\">String</span>,</span><br><span class=\"line\">    loader: <span class=\"built_in\">String</span> | <span class=\"built_in\">Array</span>,</span><br><span class=\"line\">    query: <span class=\"built_in\">String</span> | <span class=\"built_in\">Object</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"使用-loader\"><a href=\"#使用-loader\" class=\"headerlink\" title=\"使用 loader\"></a>使用 loader</h3><p><strong>第一步：安装</strong><br>loader 和 webpack 一样都是Node.js实现，发布到 npm 当中，需要使用loader的时候，只需要如下安装<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install xx-loader --save-dev</span><br><span class=\"line\"></span><br><span class=\"line\">// eg css loader</span><br><span class=\"line\">$ npm install css-loader style-loader --save-dev</span><br></pre></td></tr></table></figure></p>\n<p><strong>第二步：修改配置</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    entry: &#123;</span><br><span class=\"line\">        index: <span class=\"string\">'./src/index.js'</span>,</span><br><span class=\"line\">        a: <span class=\"string\">'./src/a.js'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    output: &#123;</span><br><span class=\"line\">        path: <span class=\"string\">'./dist/'</span>,</span><br><span class=\"line\">        filename: <span class=\"string\">'[name].js'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">        loaders: [&#123;</span><br><span class=\"line\">            test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">            exclude: <span class=\"regexp\">/node_modules/</span>,</span><br><span class=\"line\">            loader: <span class=\"string\">'babel'</span>,</span><br><span class=\"line\">            query: &#123;</span><br><span class=\"line\">                presets: [<span class=\"string\">'es2015'</span>, <span class=\"string\">'stage-0'</span>, <span class=\"string\">'react'</span>]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, &#123;</span><br><span class=\"line\">            test: <span class=\"regexp\">/\\.css$/</span>, </span><br><span class=\"line\">            loader: <span class=\"string\">\"style-loader!css-loader\"</span> </span><br><span class=\"line\">        &#125;]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>第三步：使用</strong></p>\n<p>前面我们已经使用过 jsx loader 了， loader 的使用方式有多种</p>\n<ol>\n<li><p>在配置文件中配置</p>\n</li>\n<li><p>显示的通过 require 调用</p>\n</li>\n<li><p>命令行调用</p>\n</li>\n</ol>\n<p><strong>显示的调用 require 会增加模块的耦合度，应尽量避免这种方式</strong></p>\n<p>src/style.css</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: red;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: white;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>修改 webpack 配置 entry 添加<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">entry: &#123;</span><br><span class=\"line\">    index: [<span class=\"string\">'./index.js'</span>, <span class=\"string\">'./style.css'</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>最终的编译结果会将  css 被转化为了 javascript。</p>\n<p>另一种方法是直接 require，修改./index.js:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> css = <span class=\"built_in\">require</span>(<span class=\"string\">\"css!./style.css\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>结果一样</p>\n<h2 id=\"常用Loaders\"><a href=\"#常用Loaders\" class=\"headerlink\" title=\"常用Loaders\"></a>常用Loaders</h2><h3 id=\"加载-CSS\"><a href=\"#加载-CSS\" class=\"headerlink\" title=\"加载 CSS\"></a>加载 CSS</h3><p>加载css需要 <code>css-loader</code>和<code>style-loader</code>，分别做以下两件事：</p>\n<ol>\n<li>css-loader 会遍历 CSS 文件，然后找到 url() 表达式然后处理他们</li>\n<li>style-loader 会把原来的 CSS 代码插入页面中的一个 style 标签中<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">// loader配置</span></span><br><span class=\"line\">    test: <span class=\"regexp\">/\\.css$/</span>,</span><br><span class=\"line\">    loader: <span class=\"string\">'style!css'</span> <span class=\"comment\">// 如果同时使用多个加载器，中间用 ! 连接，加载器的执行顺序是从右向左</span></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"图片处理\"><a href=\"#图片处理\" class=\"headerlink\" title=\"图片处理\"></a>图片处理</h3><p>图片处理需要 <code>url-loader</code> 和 <code>file-loader</code><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">// loader配置</span></span><br><span class=\"line\">  test: <span class=\"regexp\">/\\.(png|jpg|gif|jpeg)$/</span>,</span><br><span class=\"line\">  loader: <span class=\"string\">'url?limit=25000'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>传入的 limit 参数是告诉它图片如果不大于 25KB 的话要自动在它从属的 css 文件中转成 BASE64 字符串。</p>\n<h4 id=\"eslint\"><a href=\"#eslint\" class=\"headerlink\" title=\"eslint\"></a>eslint</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span> : &#123;</span><br><span class=\"line\">  preLoaders: [</span><br><span class=\"line\">      &#123;test: <span class=\"regexp\">/\\.js$/</span>, loader: <span class=\"string\">\"eslint-loader\"</span>, exclude: <span class=\"regexp\">/node_modules/</span>&#125;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"常用Plugin\"><a href=\"#常用Plugin\" class=\"headerlink\" title=\"常用Plugin\"></a>常用Plugin</h2><p>###UglifyJsPlugin webpack自带的插件<br>一般配置如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins: [</span><br><span class=\"line\">  <span class=\"keyword\">new</span> webpack.optimize.UglifyJsPlugin(&#123;</span><br><span class=\"line\">        compress: &#123;</span><br><span class=\"line\">            warnings: <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"extractTextWebpackPlugin\"><a href=\"#extractTextWebpackPlugin\" class=\"headerlink\" title=\"extractTextWebpackPlugin\"></a>extractTextWebpackPlugin</h3><p>在webpack中，可以通过require引入css，通过loader对文件自动解析并打包文件。通常会将css以在页面的header切入style形式加载样式。但是我们如果你想通过外链形式加载css的话，通过extract-text-webpack-plugin就可以办到。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ExtractTextPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">\"extract-text-webpack-plugin\"</span>);</span><br><span class=\"line\">plugins: [</span><br><span class=\"line\">  <span class=\"keyword\">new</span> ExtractTextPlugin(<span class=\"string\">\"app.css\"</span>)</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"htmlWebpackPlugin\"><a href=\"#htmlWebpackPlugin\" class=\"headerlink\" title=\"htmlWebpackPlugin\"></a>htmlWebpackPlugin</h3><p>生成HTML</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> HTMLWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'html-webpack-plugin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    index: <span class=\"string\">'./pages/index.js'</span>,</span><br><span class=\"line\">    page1: <span class=\"string\">'./pages/page1.js'</span>,</span><br><span class=\"line\">    page2: <span class=\"string\">'./pages/page2.js'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: path.join(__dirname, <span class=\"string\">'dist'</span>),</span><br><span class=\"line\">    filename: <span class=\"string\">'[name].js'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> HTMLWebpackPlugin(&#123;</span><br><span class=\"line\">      filename: <span class=\"string\">'index.html'</span>,</span><br><span class=\"line\">      template: <span class=\"string\">'templates/index.html'</span>,</span><br><span class=\"line\">      inject: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      chunks: [<span class=\"string\">'index'</span>]</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> HTMLWebpackPlugin(&#123;</span><br><span class=\"line\">      filename: <span class=\"string\">'page1.html'</span>,</span><br><span class=\"line\">      template: <span class=\"string\">'templates/page1.html'</span>,</span><br><span class=\"line\">      inject: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      chunks: [<span class=\"string\">'page1'</span>]</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> HTMLWebpackPlugin(&#123;</span><br><span class=\"line\">      filename: <span class=\"string\">'page2.html'</span>,</span><br><span class=\"line\">      template: <span class=\"string\">'templates/page2.html'</span>,</span><br><span class=\"line\">      inject: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      chunks: [<span class=\"string\">'page2'</span>]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"提取公共Js插件\"><a href=\"#提取公共Js插件\" class=\"headerlink\" title=\"提取公共Js插件\"></a>提取公共Js插件</h4><p>通过 <code>CommonsChunkPlugin</code> 可以将个模块的公共依赖单独打包成一个 chunk，这时webpack的运行代码会被移到<code>common chunk</code> 中，原来的 <code>entry chunk</code> 也降变为 <code>initial chunk</code>。</p>\n<p><code>entry vendor</code>配合<code>CommonsChunkPlugin</code>使用，可以分离第三方库和app代码。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">entry: &#123;</span><br><span class=\"line\">   app: <span class=\"string\">'./app.js'</span>,</span><br><span class=\"line\">   vendor: [<span class=\"string\">'jquery'</span>, <span class=\"string\">'lodash'</span>]</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">plugins: &#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(<span class=\"string\">'vendor'</span>, <span class=\"string\">'vendor.bundle.js'</span>)   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样子的话，app.js 只包含依赖的JS，但是对第三方依赖的都被排除掉了。第三方库被打包成 <code>vendor.bundle.js</code>。</p>\n<p><strong>CommonsChunkPlugin配置项：</strong></p>\n<ul>\n<li>names: chunk的名称，字符串或数组。</li>\n<li>filename: chunk文件名称，默认为output.filename或者output.chunkFilename</li>\n<li>minChunks 被几个chunk调用的moudule才会加入common chunk中，最小值为2。如果设置为Infinity，则不会有module加入到common chunk中<br>chunks: 需要提前common的源文件，默认为全部入口文件。</li>\n<li>children: 如果设置为 <code>true</code>，所有  公共chunk 的子模块都会被选择</li>\n<li>async:  如果设置为 <code>true</code>，一个异步的  公共chunk 会作为 <code>options.name</code> 的子模块，和 <code>options.chunks</code> 的兄弟模块被创建。 它会与 <code>options.chunks</code> 并行被加载。可以通过提供想要的字符串，而不是 <code>true</code> 来对输出的文件进行更换名称。</li>\n<li>minSize: 在 公共chunk 被创建立之前，所有 公共模块 (common module) 的最少大小。</li>\n</ul>\n<h4 id=\"ProvidePlugin插件\"><a href=\"#ProvidePlugin插件\" class=\"headerlink\" title=\"ProvidePlugin插件\"></a>ProvidePlugin插件</h4><p>将模块暴露到全局</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> webpack.ProvidePlugin(&#123;</span><br><span class=\"line\">    <span class=\"string\">\"R\"</span>: <span class=\"string\">\"report\"</span>,</span><br><span class=\"line\">&#125;),</span><br></pre></td></tr></table></figure>\n<h4 id=\"删除目录插件\"><a href=\"#删除目录插件\" class=\"headerlink\" title=\"删除目录插件\"></a>删除目录插件</h4><p>clean-webpack-plugin<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> CleanPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">\"clean-webpack-plugin\"</span>);</span><br><span class=\"line\">plugins: [</span><br><span class=\"line\">  <span class=\"keyword\">new</span> CleanPlugin([<span class=\"string\">'dist'</span>]),</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"拷贝文件插件\"><a href=\"#拷贝文件插件\" class=\"headerlink\" title=\"拷贝文件插件\"></a>拷贝文件插件</h4><p>copy-webpack-plugin<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> CopyWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'copy-webpack-plugin'</span>);</span><br><span class=\"line\">plugins: [</span><br><span class=\"line\">  <span class=\"keyword\">new</span> CopyWebpackPlugin([&#123;</span><br><span class=\"line\">    <span class=\"keyword\">from</span>: __dirname + <span class=\"string\">'/src/public'</span></span><br><span class=\"line\">  &#125;])</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"优化第三方包插件\"><a href=\"#优化第三方包插件\" class=\"headerlink\" title=\"优化第三方包插件\"></a>优化第三方包插件</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins: [</span><br><span class=\"line\">  <span class=\"keyword\">new</span> webpack.DefinePlugin(&#123;</span><br><span class=\"line\">      <span class=\"comment\">//去掉react中的警告，react会自己判断</span></span><br><span class=\"line\">      <span class=\"string\">'process.env'</span>: &#123;</span><br><span class=\"line\">          NODE_ENV: <span class=\"string\">'\"production\"'</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<h4 id=\"自动打开浏览器插件\"><a href=\"#自动打开浏览器插件\" class=\"headerlink\" title=\"自动打开浏览器插件\"></a>自动打开浏览器插件</h4><p>open-browser-webpack-plugin<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 自动打开浏览器插件</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> OpenBrowserPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'open-browser-webpack-plugin'</span>);</span><br><span class=\"line\">plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> OpenBrowserPlugin(&#123;url: <span class=\"string\">'http://localhost:8080/'</span>, browser: <span class=\"string\">'chrome'</span>&#125;)</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>\n<p>plugin 为 webpack 提供了更多的自定义功能。<br>就不一一列举了，点击<br> <a href=\"https://github.com/webpack-contrib/awesome-webpack#webpack-plugins\" target=\"_blank\" rel=\"external\">webpack-plugins</a></p>\n<h3 id=\"Resolve属性\"><a href=\"#Resolve属性\" class=\"headerlink\" title=\"Resolve属性\"></a>Resolve属性</h3><p>webpack 在构建包的时候会按配置进行模块的查找<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">resolve: &#123;</span><br><span class=\"line\">     <span class=\"comment\">//查找module的话从这里开始查找</span></span><br><span class=\"line\">     root: <span class=\"string\">'/pomy/github/flux-example/src'</span>, <span class=\"comment\">//绝对路径</span></span><br><span class=\"line\">     <span class=\"comment\">//自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名</span></span><br><span class=\"line\">     <span class=\"comment\">//注意一下, extensions 第一个是空字符串! 对应不需要后缀的情况.</span></span><br><span class=\"line\">     extensions: [<span class=\"string\">''</span>, <span class=\"string\">'.js'</span>, <span class=\"string\">'.json'</span>, <span class=\"string\">'.scss'</span>,’jsx’],</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">//模块别名定义，方便后续直接引用别名，无须多写长长的地址</span></span><br><span class=\"line\">     alias: &#123;</span><br><span class=\"line\">         AppStore : <span class=\"string\">'js/stores/AppStores.js'</span>,<span class=\"comment\">//后续直接 require('AppStore') 即可</span></span><br><span class=\"line\">         ActionType : <span class=\"string\">'js/actions/ActionType.js'</span>,</span><br><span class=\"line\">         AppAction : <span class=\"string\">'js/actions/AppAction.js'</span></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Externals属性\"><a href=\"#Externals属性\" class=\"headerlink\" title=\"Externals属性\"></a>Externals属性</h3><p>外部依赖不需要打包进 bundle，当我们想在项目中 require 一些其他的类库或者 API ，而又不想让这些类库的源码被构建到运行时文件中，这在实际开发中很有必要。 比如：在页面里通过 script 标签引用了 jQuery：<code>&lt;script src=&quot;//code.jquery.com/jquery-1.12.0.min.js&quot;&gt;&lt;/script&gt;</code>，所以并不想在其他 js 里再打包进入一遍，比如你的其他 js 代码类似：</p>\n<p>其实就是不是通过require或者import引入的，而是直接写在html中的js地址。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 配置了这个属性之后 react 和 react-dom 这些第三方的包都不会被构建进 js 中，那么我们就需要通过 cdn 进行文件的引用了</span></span><br><span class=\"line\"><span class=\"comment\">// 前边的这个名称是在项目中引用用的，相当于 import React from 'react1' 中的 react</span></span><br><span class=\"line\">externals: &#123;</span><br><span class=\"line\">    <span class=\"string\">'react1'</span>: <span class=\"string\">'react'</span>,</span><br><span class=\"line\">    <span class=\"string\">'react-dom1'</span>: <span class=\"string\">'react-dom'</span>,</span><br><span class=\"line\">    <span class=\"string\">'$1'</span>: <span class=\"string\">'jQuery'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样用了 externals 属性时不用分离插件了，作用是这里引的插件不会被 webpack 所打包。要么用 cdn 要么需要 webpack 打包。</p>\n<h3 id=\"noParse属性\"><a href=\"#noParse属性\" class=\"headerlink\" title=\"noParse属性\"></a>noParse属性</h3><p>module.noParse 是 webpack 的另一个很有用的配置项，如果确定一个模块中没有其他新的依赖项就可以配置这个像，webpack 将不再扫描这个文件中的依赖。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">  noParse: [<span class=\"regexp\">/moment-with-locales/</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","excerpt":"<h2 id=\"webpack\"><a href=\"#webpack\" class=\"headerlink\" title=\"webpack\"></a>webpack</h2><p>webpack在前端工程中越来越多见，当前流行的vue、react、weex等都推荐webpack作为打包工具。所以在这前端打包工具众多，但是没有一个最好用的时代，这应该是最值得去学习的前端打包工具。<br>","more":"</p>\n<h3 id=\"webpack是什么\"><a href=\"#webpack是什么\" class=\"headerlink\" title=\"webpack是什么\"></a>webpack是什么</h3><blockquote><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.</p>\n<footer><strong>官方解释</strong><cite><a href=\"https://webpack.github.io/docs/what-is-webpack.html\">webpack.github.io/docs/what-is-webpack.html</a></cite></footer></blockquote>\n<img src=\"http://om64pi295.bkt.clouddn.com/what-is-webpack.png\" class=\"[what is webpack]\">\n<p>Webpack是一个模块打包工具，将包含有依赖关系的模块集打包合并。Webpack 不仅支持 CommonJs 和 AMD 的模块定义方式的Js，还可以将css、图片、文本等前端资源视为模板。</p>\n<h3 id=\"为什么要webpack\"><a href=\"#为什么要webpack\" class=\"headerlink\" title=\"为什么要webpack\"></a>为什么要webpack</h3><p>网站进化成Web app，交互越来越复杂，JavaScript文件体积越来越大。通过 <code>&lt;script&gt;</code>标签加载js容易引起冲突、阻塞加载等问题，虽然之后出现了RequireJs、Seajs等模块载入框架解决了以上问题，随着定义模块以及模块依赖的方法层出不穷，Webpack获得追捧 。Webpack不仅支持支持多种模块系统风格，而且也支持分段加载、延迟加载等功能，可谓集大成者。</p>\n<h2 id=\"Webpack配置\"><a href=\"#Webpack配置\" class=\"headerlink\" title=\"Webpack配置\"></a>Webpack配置</h2><p><strong>Webpack 的三个核心概念</strong></p>\n<p>1.<strong>loader</strong>：通过各种资源转换器，将它们转换成对应模块引入<br>2.<strong>chunk</strong>：实现按需加载，避免Js文件过大导致阻塞加载。</p>\n<h3 id=\"安装配置\"><a href=\"#安装配置\" class=\"headerlink\" title=\"安装配置\"></a>安装配置</h3><p><strong>第一步：Node.js</strong></p>\n<p>webpack 是 Node 实现，首先需要到 Node.js 下载安装最新版本的 Node.js</p>\n<p><strong>第二步：全局安装webpack-和webpack-dev-server</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// -g 参数表示全局安装</span><br><span class=\"line\">$ npm i -g webpack webpack-dev-server</span><br></pre></td></tr></table></figure>\n<p><strong>第三步：新建前端项目以及安装webpack</strong></p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── index<span class=\"selector-class\">.html</span>      <span class=\"comment\">// 入口 HTML  </span></span><br><span class=\"line\">├── main<span class=\"selector-class\">.js</span>         <span class=\"comment\">// 入口 JS</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"bundle.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">'&lt;h1&gt;Hello World&lt;/h1&gt;'</span>);</span><br></pre></td></tr></table></figure>\n<p><strong>第四步：在项目中安装webpack</strong><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 初始化 package.json,  根据提示填写 package.json 的相关信息</span><br><span class=\"line\">$ npm init</span><br><span class=\"line\"></span><br><span class=\"line\">// 下载 webpack 依赖 </span><br><span class=\"line\">// --save-dev 表示将依赖添加到 package.json 中的 <span class=\"string\">'devDependencies'</span> 对象中</span><br><span class=\"line\">$  npm install webpack --save-dev</span><br></pre></td></tr></table></figure></p>\n<p><strong>第五步 调用</strong><br><strong>命令行调用</strong><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpack main.js</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hash: 000934e5d93f498db0f5</span><br><span class=\"line\">Version: webpack 1.14.0</span><br><span class=\"line\">Time: 49ms</span><br><span class=\"line\">    Asset     Size  Chunks             Chunk Names</span><br><span class=\"line\">bundle.js  1.57 kB       0  [emitted]  main</span><br><span class=\"line\">   [0] multi main 40 bytes &#123;0&#125; [built]</span><br><span class=\"line\">   [1] ./main.js 41 bytes &#123;0&#125; [built]</span><br></pre></td></tr></table></figure>\n<p>执行后，可在浏览器打开 index.html</p>\n<p><strong>通过配置文件执行</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  entry: <span class=\"string\">'./main.js'</span>,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    filename: <span class=\"string\">'bundle.js'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>文件编译执行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpack</span><br></pre></td></tr></table></figure>\n<p>内存编译执行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpack-dev-server</span><br></pre></td></tr></table></figure>\n<p>一般我们都是通过配置文件投入生产，我们可以在配置指定多个入口文件、代码分离、暴露JS全局变量、编译CSS、压缩图片等等。阮老师做了一个 <a href=\"https://github.com/ruanyf/webpack-demos\" title=\"webpack-demo\">webpack-demo</a>写了很多简单的例子，是份不错的学习资料。所以这篇文章就不再介绍基本用法了。</p>\n<h2 id=\"Chunk\"><a href=\"#Chunk\" class=\"headerlink\" title=\"Chunk\"></a>Chunk</h2><h3 id=\"Chunk是什么？\"><a href=\"#Chunk是什么？\" class=\"headerlink\" title=\"Chunk是什么？\"></a>Chunk是什么？</h3><p>webpack中 Chunk 实际上就是输出的 .js 文件，可能包含多个模块，主要的作用是为了优化异步加载。</p>\n<h3 id=\"Chuck包含了哪些内容\"><a href=\"#Chuck包含了哪些内容\" class=\"headerlink\" title=\"Chuck包含了哪些内容\"></a>Chuck包含了哪些内容</h3><ul>\n<li>同步情况下：一个 Check 会把模块中的所有依赖都加载到 Chunk 中</li>\n<li>异步情况下：所有被切割点分开的依赖被加载到一个 Chunk</li>\n</ul>\n<p><strong>require.ensure跟require都会被加载到一个 Chunk中</strong></p>\n<h3 id=\"Chunk-分类\"><a href=\"#Chunk-分类\" class=\"headerlink\" title=\"Chunk 分类\"></a>Chunk 分类</h3><p>第三方库不需要打包到发布的文件中，这是几需要vendor，将第三方库打包成一个chunk。</p>\n<p>webpack将chunk类型分为三种<strong>Entry chunk</strong>，<strong>Normal chunk</strong>，<strong>Initial chunk</strong>。<br><strong>Entry Chunk</strong><br>包括两部分代码：webpack运行代码（如webpackJsonp, <strong>webpack_require</strong> 等函数）和模块代码。</p>\n<p><strong>Normal Chunk</strong><br>只包含模块代码</p>\n<p><strong>Initial  Chunk</strong><br>本质上为Normal Chunk。但是他计算载入时间，比Normal Chunk更重要。一般在使用 CommonsChunkPlugin 时出现。</p>\n<p>webpack 可以将代码切割成不同的 chunk，实现按需加载。</p>\n<h2 id=\"loaders\"><a href=\"#loaders\" class=\"headerlink\" title=\"loaders\"></a>loaders</h2><h3 id=\"什么是loaders\"><a href=\"#什么是loaders\" class=\"headerlink\" title=\"什么是loaders\"></a>什么是loaders</h3><blockquote><p>Loaders are transformations that are applied on a resource file of your app. They are functions (running in node.js) that take the source of a resource file as the parameter and return the new source.</p>\n</blockquote>\n<p>意思就是在webpack中，通过loader可以显示静态资源的转换。</p>\n<h3 id=\"loader-功能\"><a href=\"#loader-功能\" class=\"headerlink\" title=\"loader 功能\"></a>loader 功能</h3><ol>\n<li>loader 管道：在同一种类型的源文件上，可以同时执行多个 loader ， loader 的执行方式可以类似管道的方式，管道执行的方式是从右到左的方式loader 可以支持同步和异步</li>\n<li><p>loader 可以接收配置参数</p>\n</li>\n<li><p>loader 可以通过正则表达式或者文件后缀指定特定类型的源文件</p>\n</li>\n<li><p>插件可以提供给 loader 更多功能</p>\n</li>\n<li><p>loader 除了做文件转换以外，还可以创建额外的文件</p>\n</li>\n</ol>\n<h3 id=\"loader-配置\"><a href=\"#loader-配置\" class=\"headerlink\" title=\"loader 配置\"></a>loader 配置</h3><p>在webpack.config.js 的module.loaders数组中新增一个loader配置。</p>\n<p>一个 loader 的配置：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过扩展名称和正则表单时来匹配资源文件</span></span><br><span class=\"line\">    test: <span class=\"built_in\">String</span>,</span><br><span class=\"line\">    loader: <span class=\"built_in\">String</span> | <span class=\"built_in\">Array</span>,</span><br><span class=\"line\">    query: <span class=\"built_in\">String</span> | <span class=\"built_in\">Object</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"使用-loader\"><a href=\"#使用-loader\" class=\"headerlink\" title=\"使用 loader\"></a>使用 loader</h3><p><strong>第一步：安装</strong><br>loader 和 webpack 一样都是Node.js实现，发布到 npm 当中，需要使用loader的时候，只需要如下安装<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install xx-loader --save-dev</span><br><span class=\"line\"></span><br><span class=\"line\">// eg css loader</span><br><span class=\"line\">$ npm install css-loader style-loader --save-dev</span><br></pre></td></tr></table></figure></p>\n<p><strong>第二步：修改配置</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    entry: &#123;</span><br><span class=\"line\">        index: <span class=\"string\">'./src/index.js'</span>,</span><br><span class=\"line\">        a: <span class=\"string\">'./src/a.js'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    output: &#123;</span><br><span class=\"line\">        path: <span class=\"string\">'./dist/'</span>,</span><br><span class=\"line\">        filename: <span class=\"string\">'[name].js'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">        loaders: [&#123;</span><br><span class=\"line\">            test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">            exclude: <span class=\"regexp\">/node_modules/</span>,</span><br><span class=\"line\">            loader: <span class=\"string\">'babel'</span>,</span><br><span class=\"line\">            query: &#123;</span><br><span class=\"line\">                presets: [<span class=\"string\">'es2015'</span>, <span class=\"string\">'stage-0'</span>, <span class=\"string\">'react'</span>]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, &#123;</span><br><span class=\"line\">            test: <span class=\"regexp\">/\\.css$/</span>, </span><br><span class=\"line\">            loader: <span class=\"string\">\"style-loader!css-loader\"</span> </span><br><span class=\"line\">        &#125;]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>第三步：使用</strong></p>\n<p>前面我们已经使用过 jsx loader 了， loader 的使用方式有多种</p>\n<ol>\n<li><p>在配置文件中配置</p>\n</li>\n<li><p>显示的通过 require 调用</p>\n</li>\n<li><p>命令行调用</p>\n</li>\n</ol>\n<p><strong>显示的调用 require 会增加模块的耦合度，应尽量避免这种方式</strong></p>\n<p>src/style.css</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: red;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: white;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>修改 webpack 配置 entry 添加<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">entry: &#123;</span><br><span class=\"line\">    index: [<span class=\"string\">'./index.js'</span>, <span class=\"string\">'./style.css'</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>最终的编译结果会将  css 被转化为了 javascript。</p>\n<p>另一种方法是直接 require，修改./index.js:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> css = <span class=\"built_in\">require</span>(<span class=\"string\">\"css!./style.css\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>结果一样</p>\n<h2 id=\"常用Loaders\"><a href=\"#常用Loaders\" class=\"headerlink\" title=\"常用Loaders\"></a>常用Loaders</h2><h3 id=\"加载-CSS\"><a href=\"#加载-CSS\" class=\"headerlink\" title=\"加载 CSS\"></a>加载 CSS</h3><p>加载css需要 <code>css-loader</code>和<code>style-loader</code>，分别做以下两件事：</p>\n<ol>\n<li>css-loader 会遍历 CSS 文件，然后找到 url() 表达式然后处理他们</li>\n<li>style-loader 会把原来的 CSS 代码插入页面中的一个 style 标签中<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">// loader配置</span></span><br><span class=\"line\">    test: <span class=\"regexp\">/\\.css$/</span>,</span><br><span class=\"line\">    loader: <span class=\"string\">'style!css'</span> <span class=\"comment\">// 如果同时使用多个加载器，中间用 ! 连接，加载器的执行顺序是从右向左</span></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"图片处理\"><a href=\"#图片处理\" class=\"headerlink\" title=\"图片处理\"></a>图片处理</h3><p>图片处理需要 <code>url-loader</code> 和 <code>file-loader</code><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">// loader配置</span></span><br><span class=\"line\">  test: <span class=\"regexp\">/\\.(png|jpg|gif|jpeg)$/</span>,</span><br><span class=\"line\">  loader: <span class=\"string\">'url?limit=25000'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>传入的 limit 参数是告诉它图片如果不大于 25KB 的话要自动在它从属的 css 文件中转成 BASE64 字符串。</p>\n<h4 id=\"eslint\"><a href=\"#eslint\" class=\"headerlink\" title=\"eslint\"></a>eslint</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span> : &#123;</span><br><span class=\"line\">  preLoaders: [</span><br><span class=\"line\">      &#123;test: <span class=\"regexp\">/\\.js$/</span>, loader: <span class=\"string\">\"eslint-loader\"</span>, exclude: <span class=\"regexp\">/node_modules/</span>&#125;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"常用Plugin\"><a href=\"#常用Plugin\" class=\"headerlink\" title=\"常用Plugin\"></a>常用Plugin</h2><p>###UglifyJsPlugin webpack自带的插件<br>一般配置如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins: [</span><br><span class=\"line\">  <span class=\"keyword\">new</span> webpack.optimize.UglifyJsPlugin(&#123;</span><br><span class=\"line\">        compress: &#123;</span><br><span class=\"line\">            warnings: <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"extractTextWebpackPlugin\"><a href=\"#extractTextWebpackPlugin\" class=\"headerlink\" title=\"extractTextWebpackPlugin\"></a>extractTextWebpackPlugin</h3><p>在webpack中，可以通过require引入css，通过loader对文件自动解析并打包文件。通常会将css以在页面的header切入style形式加载样式。但是我们如果你想通过外链形式加载css的话，通过extract-text-webpack-plugin就可以办到。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ExtractTextPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">\"extract-text-webpack-plugin\"</span>);</span><br><span class=\"line\">plugins: [</span><br><span class=\"line\">  <span class=\"keyword\">new</span> ExtractTextPlugin(<span class=\"string\">\"app.css\"</span>)</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"htmlWebpackPlugin\"><a href=\"#htmlWebpackPlugin\" class=\"headerlink\" title=\"htmlWebpackPlugin\"></a>htmlWebpackPlugin</h3><p>生成HTML</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> HTMLWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'html-webpack-plugin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    index: <span class=\"string\">'./pages/index.js'</span>,</span><br><span class=\"line\">    page1: <span class=\"string\">'./pages/page1.js'</span>,</span><br><span class=\"line\">    page2: <span class=\"string\">'./pages/page2.js'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: path.join(__dirname, <span class=\"string\">'dist'</span>),</span><br><span class=\"line\">    filename: <span class=\"string\">'[name].js'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> HTMLWebpackPlugin(&#123;</span><br><span class=\"line\">      filename: <span class=\"string\">'index.html'</span>,</span><br><span class=\"line\">      template: <span class=\"string\">'templates/index.html'</span>,</span><br><span class=\"line\">      inject: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      chunks: [<span class=\"string\">'index'</span>]</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> HTMLWebpackPlugin(&#123;</span><br><span class=\"line\">      filename: <span class=\"string\">'page1.html'</span>,</span><br><span class=\"line\">      template: <span class=\"string\">'templates/page1.html'</span>,</span><br><span class=\"line\">      inject: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      chunks: [<span class=\"string\">'page1'</span>]</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> HTMLWebpackPlugin(&#123;</span><br><span class=\"line\">      filename: <span class=\"string\">'page2.html'</span>,</span><br><span class=\"line\">      template: <span class=\"string\">'templates/page2.html'</span>,</span><br><span class=\"line\">      inject: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      chunks: [<span class=\"string\">'page2'</span>]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"提取公共Js插件\"><a href=\"#提取公共Js插件\" class=\"headerlink\" title=\"提取公共Js插件\"></a>提取公共Js插件</h4><p>通过 <code>CommonsChunkPlugin</code> 可以将个模块的公共依赖单独打包成一个 chunk，这时webpack的运行代码会被移到<code>common chunk</code> 中，原来的 <code>entry chunk</code> 也降变为 <code>initial chunk</code>。</p>\n<p><code>entry vendor</code>配合<code>CommonsChunkPlugin</code>使用，可以分离第三方库和app代码。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">entry: &#123;</span><br><span class=\"line\">   app: <span class=\"string\">'./app.js'</span>,</span><br><span class=\"line\">   vendor: [<span class=\"string\">'jquery'</span>, <span class=\"string\">'lodash'</span>]</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">plugins: &#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(<span class=\"string\">'vendor'</span>, <span class=\"string\">'vendor.bundle.js'</span>)   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样子的话，app.js 只包含依赖的JS，但是对第三方依赖的都被排除掉了。第三方库被打包成 <code>vendor.bundle.js</code>。</p>\n<p><strong>CommonsChunkPlugin配置项：</strong></p>\n<ul>\n<li>names: chunk的名称，字符串或数组。</li>\n<li>filename: chunk文件名称，默认为output.filename或者output.chunkFilename</li>\n<li>minChunks 被几个chunk调用的moudule才会加入common chunk中，最小值为2。如果设置为Infinity，则不会有module加入到common chunk中<br>chunks: 需要提前common的源文件，默认为全部入口文件。</li>\n<li>children: 如果设置为 <code>true</code>，所有  公共chunk 的子模块都会被选择</li>\n<li>async:  如果设置为 <code>true</code>，一个异步的  公共chunk 会作为 <code>options.name</code> 的子模块，和 <code>options.chunks</code> 的兄弟模块被创建。 它会与 <code>options.chunks</code> 并行被加载。可以通过提供想要的字符串，而不是 <code>true</code> 来对输出的文件进行更换名称。</li>\n<li>minSize: 在 公共chunk 被创建立之前，所有 公共模块 (common module) 的最少大小。</li>\n</ul>\n<h4 id=\"ProvidePlugin插件\"><a href=\"#ProvidePlugin插件\" class=\"headerlink\" title=\"ProvidePlugin插件\"></a>ProvidePlugin插件</h4><p>将模块暴露到全局</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> webpack.ProvidePlugin(&#123;</span><br><span class=\"line\">    <span class=\"string\">\"R\"</span>: <span class=\"string\">\"report\"</span>,</span><br><span class=\"line\">&#125;),</span><br></pre></td></tr></table></figure>\n<h4 id=\"删除目录插件\"><a href=\"#删除目录插件\" class=\"headerlink\" title=\"删除目录插件\"></a>删除目录插件</h4><p>clean-webpack-plugin<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> CleanPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">\"clean-webpack-plugin\"</span>);</span><br><span class=\"line\">plugins: [</span><br><span class=\"line\">  <span class=\"keyword\">new</span> CleanPlugin([<span class=\"string\">'dist'</span>]),</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"拷贝文件插件\"><a href=\"#拷贝文件插件\" class=\"headerlink\" title=\"拷贝文件插件\"></a>拷贝文件插件</h4><p>copy-webpack-plugin<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> CopyWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'copy-webpack-plugin'</span>);</span><br><span class=\"line\">plugins: [</span><br><span class=\"line\">  <span class=\"keyword\">new</span> CopyWebpackPlugin([&#123;</span><br><span class=\"line\">    <span class=\"keyword\">from</span>: __dirname + <span class=\"string\">'/src/public'</span></span><br><span class=\"line\">  &#125;])</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"优化第三方包插件\"><a href=\"#优化第三方包插件\" class=\"headerlink\" title=\"优化第三方包插件\"></a>优化第三方包插件</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins: [</span><br><span class=\"line\">  <span class=\"keyword\">new</span> webpack.DefinePlugin(&#123;</span><br><span class=\"line\">      <span class=\"comment\">//去掉react中的警告，react会自己判断</span></span><br><span class=\"line\">      <span class=\"string\">'process.env'</span>: &#123;</span><br><span class=\"line\">          NODE_ENV: <span class=\"string\">'\"production\"'</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<h4 id=\"自动打开浏览器插件\"><a href=\"#自动打开浏览器插件\" class=\"headerlink\" title=\"自动打开浏览器插件\"></a>自动打开浏览器插件</h4><p>open-browser-webpack-plugin<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 自动打开浏览器插件</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> OpenBrowserPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'open-browser-webpack-plugin'</span>);</span><br><span class=\"line\">plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> OpenBrowserPlugin(&#123;url: <span class=\"string\">'http://localhost:8080/'</span>, browser: <span class=\"string\">'chrome'</span>&#125;)</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>\n<p>plugin 为 webpack 提供了更多的自定义功能。<br>就不一一列举了，点击<br> <a href=\"https://github.com/webpack-contrib/awesome-webpack#webpack-plugins\">webpack-plugins</a></p>\n<h3 id=\"Resolve属性\"><a href=\"#Resolve属性\" class=\"headerlink\" title=\"Resolve属性\"></a>Resolve属性</h3><p>webpack 在构建包的时候会按配置进行模块的查找<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">resolve: &#123;</span><br><span class=\"line\">     <span class=\"comment\">//查找module的话从这里开始查找</span></span><br><span class=\"line\">     root: <span class=\"string\">'/pomy/github/flux-example/src'</span>, <span class=\"comment\">//绝对路径</span></span><br><span class=\"line\">     <span class=\"comment\">//自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名</span></span><br><span class=\"line\">     <span class=\"comment\">//注意一下, extensions 第一个是空字符串! 对应不需要后缀的情况.</span></span><br><span class=\"line\">     extensions: [<span class=\"string\">''</span>, <span class=\"string\">'.js'</span>, <span class=\"string\">'.json'</span>, <span class=\"string\">'.scss'</span>,’jsx’],</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">//模块别名定义，方便后续直接引用别名，无须多写长长的地址</span></span><br><span class=\"line\">     alias: &#123;</span><br><span class=\"line\">         AppStore : <span class=\"string\">'js/stores/AppStores.js'</span>,<span class=\"comment\">//后续直接 require('AppStore') 即可</span></span><br><span class=\"line\">         ActionType : <span class=\"string\">'js/actions/ActionType.js'</span>,</span><br><span class=\"line\">         AppAction : <span class=\"string\">'js/actions/AppAction.js'</span></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Externals属性\"><a href=\"#Externals属性\" class=\"headerlink\" title=\"Externals属性\"></a>Externals属性</h3><p>外部依赖不需要打包进 bundle，当我们想在项目中 require 一些其他的类库或者 API ，而又不想让这些类库的源码被构建到运行时文件中，这在实际开发中很有必要。 比如：在页面里通过 script 标签引用了 jQuery：<code>&lt;script src=&quot;//code.jquery.com/jquery-1.12.0.min.js&quot;&gt;&lt;/script&gt;</code>，所以并不想在其他 js 里再打包进入一遍，比如你的其他 js 代码类似：</p>\n<p>其实就是不是通过require或者import引入的，而是直接写在html中的js地址。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 配置了这个属性之后 react 和 react-dom 这些第三方的包都不会被构建进 js 中，那么我们就需要通过 cdn 进行文件的引用了</span></span><br><span class=\"line\"><span class=\"comment\">// 前边的这个名称是在项目中引用用的，相当于 import React from 'react1' 中的 react</span></span><br><span class=\"line\">externals: &#123;</span><br><span class=\"line\">    <span class=\"string\">'react1'</span>: <span class=\"string\">'react'</span>,</span><br><span class=\"line\">    <span class=\"string\">'react-dom1'</span>: <span class=\"string\">'react-dom'</span>,</span><br><span class=\"line\">    <span class=\"string\">'$1'</span>: <span class=\"string\">'jQuery'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样用了 externals 属性时不用分离插件了，作用是这里引的插件不会被 webpack 所打包。要么用 cdn 要么需要 webpack 打包。</p>\n<h3 id=\"noParse属性\"><a href=\"#noParse属性\" class=\"headerlink\" title=\"noParse属性\"></a>noParse属性</h3><p>module.noParse 是 webpack 的另一个很有用的配置项，如果确定一个模块中没有其他新的依赖项就可以配置这个像，webpack 将不再扫描这个文件中的依赖。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">  noParse: [<span class=\"regexp\">/moment-with-locales/</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cj5rrqjdm0000fkf1r2qsano6","category_id":"cj5rrqje00004fkf167tj5wws","_id":"cj5rrqjec000cfkf1dkisgdrc"},{"post_id":"cj5rrqje10005fkf1lymjgte9","category_id":"cj5rrqje90009fkf16wgnjn3f","_id":"cj5rrqjef000gfkf12hienuju"},{"post_id":"cj5rrqjea000bfkf1pmrd74pp","category_id":"cj5rrqjed000efkf1ml67pyqw","_id":"cj5rrqjeh000ifkf1wyj77oc2"},{"post_id":"cj5rrqjdt0002fkf1cl0ob8z5","category_id":"cj5rwfv2x0001r4f1klorxwwd","_id":"cj5rwfv360004r4f13fstqa56"},{"post_id":"cj5rrqje30006fkf1vnjudpud","category_id":"cj5rwfv2x0001r4f1klorxwwd","_id":"cj5rwfv370008r4f1oqbknxv1"},{"post_id":"cj5rrqje70008fkf1hughf1ix","category_id":"cj5rwfv2x0001r4f1klorxwwd","_id":"cj5rwfv39000br4f1tsnnjsa5"}],"PostTag":[{"post_id":"cj5rrqjdm0000fkf1r2qsano6","tag_id":"cj5rrqjdx0003fkf1gi87vfuc","_id":"cj5rrqjea000afkf15iy3yfq8"},{"post_id":"cj5rrqje10005fkf1lymjgte9","tag_id":"cj5rrqje50007fkf10shfdr6h","_id":"cj5rrqjed000ffkf1pu1cppna"},{"post_id":"cj5rrqjdt0002fkf1cl0ob8z5","tag_id":"cj5rwfv2s0000r4f19zy2xikg","_id":"cj5rwfv370007r4f1i2p3atbd"},{"post_id":"cj5rrqjdt0002fkf1cl0ob8z5","tag_id":"cj5rwfv330002r4f1ie3dk3hi","_id":"cj5rwfv380009r4f1u1uov21g"},{"post_id":"cj5rrqje30006fkf1vnjudpud","tag_id":"cj5rwfv2s0000r4f19zy2xikg","_id":"cj5rwfv3a000dr4f1oltqtf8r"},{"post_id":"cj5rrqje30006fkf1vnjudpud","tag_id":"cj5rwfv38000ar4f1r07fkgew","_id":"cj5rwfv3a000er4f1m3tj9p6g"},{"post_id":"cj5rrqje70008fkf1hughf1ix","tag_id":"cj5rwfv2s0000r4f19zy2xikg","_id":"cj5rwfv3c000hr4f1bd3ufseu"},{"post_id":"cj5rrqje70008fkf1hughf1ix","tag_id":"cj5rwfv38000ar4f1r07fkgew","_id":"cj5rwfv3c000ir4f13lap8t1x"},{"post_id":"cj5rrqjea000bfkf1pmrd74pp","tag_id":"cj5rwfv3b000gr4f1il98l1n4","_id":"cj5rwfv3d000kr4f18l6xj43r"},{"post_id":"cj5rrqjea000bfkf1pmrd74pp","tag_id":"cj5rwfv3c000jr4f1p8v7fvum","_id":"cj5rwfv3e000lr4f19a7tlb7h"}],"Tag":[{"name":"hexo","_id":"cj5rrqjdx0003fkf1gi87vfuc"},{"name":"技术细节 cross-dev","_id":"cj5rrqje50007fkf10shfdr6h"},{"name":"webpack webpack1.x","_id":"cj5rrqjec000dfkf1lokur5x8"},{"name":"JavaScript 验证身份证号码","_id":"cj5rrxw03000jfkf1pfxd95k7"},{"name":"JavaScript","_id":"cj5rwfv2s0000r4f19zy2xikg"},{"name":"JS实际应用","_id":"cj5rwfv330002r4f1ie3dk3hi"},{"name":"正则","_id":"cj5rwfv38000ar4f1r07fkgew"},{"name":"webpack","_id":"cj5rwfv3b000gr4f1il98l1n4"},{"name":"webpack1.x","_id":"cj5rwfv3c000jr4f1p8v7fvum"}]}}